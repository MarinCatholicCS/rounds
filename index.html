<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROUNDS</title>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyB_t0aqBd6HG-F2ncaarCQyApQoFN9yR48",
            authDomain: "rounds-mc.firebaseapp.com",
            databaseURL: "https://rounds-mc-default-rtdb.firebaseio.com",
            projectId: "rounds-mc",
            storageBucket: "rounds-mc.firebasestorage.app",
            messagingSenderId: "594850049392",
            appId: "1:594850049392:web:8b883a924fe2428113f3b5"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #0a0a0f;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameContainer { position: relative; width: 1200px; height: 700px; }
        
        canvas {
            display: block;
            border-radius: 8px;
            box-shadow: 0 0 60px rgba(255, 100, 50, 0.15);
            cursor: crosshair;
        }
        
        #mainMenu, #onlineMenu, #lobby, #customizeMenu {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .hidden { display: none !important; }
        
        .menu-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 140px;
            color: #fff;
            text-shadow: 0 0 40px rgba(255, 100, 50, 0.8), 0 0 80px rgba(255, 50, 50, 0.5);
            letter-spacing: 20px;
            margin-bottom: 60px;
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 40px rgba(255, 100, 50, 0.8), 0 0 80px rgba(255, 50, 50, 0.5); }
            50% { text-shadow: 0 0 60px rgba(255, 100, 50, 1), 0 0 120px rgba(255, 50, 50, 0.7); }
        }
        
        .menu-btn {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 36px;
            padding: 18px 80px;
            margin: 12px;
            background: linear-gradient(180deg, #ff6b35 0%, #e63946 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            letter-spacing: 4px;
            transition: all 0.2s ease;
            box-shadow: 0 6px 0 #a62639, 0 10px 30px rgba(230, 57, 70, 0.4);
        }
        
        .menu-btn:hover { transform: translateY(-4px); box-shadow: 0 10px 0 #a62639, 0 16px 40px rgba(230, 57, 70, 0.6); }
        .menu-btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #a62639, 0 4px 20px rgba(230, 57, 70, 0.4); }
        
        .menu-btn.secondary { background: linear-gradient(180deg, #4361ee 0%, #3a0ca3 100%); box-shadow: 0 6px 0 #240046, 0 10px 30px rgba(67, 97, 238, 0.4); }
        .menu-btn.online { background: linear-gradient(180deg, #10b981 0%, #059669 100%); box-shadow: 0 6px 0 #047857, 0 10px 30px rgba(16, 185, 129, 0.4); }
        .menu-btn.customize { background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%); box-shadow: 0 6px 0 #b45309, 0 10px 30px rgba(245, 158, 11, 0.4); }
        .menu-btn.back-btn { background: linear-gradient(180deg, #6b7280 0%, #4b5563 100%); box-shadow: 0 6px 0 #374151, 0 10px 30px rgba(107, 114, 128, 0.4); margin-top: 30px; padding: 12px 50px; font-size: 24px; }
        
        .room-input {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 36px;
            padding: 15px 30px;
            background: #1a1a2e;
            border: 3px solid #4361ee;
            border-radius: 8px;
            color: white;
            text-align: center;
            letter-spacing: 8px;
            width: 220px;
            outline: none;
            text-transform: uppercase;
        }
        
        .room-input:focus { border-color: #6b8cff; box-shadow: 0 0 20px rgba(67, 97, 238, 0.5); }
        
        .room-code {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 72px;
            color: #10b981;
            letter-spacing: 15px;
            text-shadow: 0 0 30px rgba(16, 185, 129, 0.6);
            margin: 20px 0;
        }
        
        .lobby-status { color: #888; font-size: 18px; margin-bottom: 30px; }
        
        .lobby-players { display: flex; gap: 60px; margin-bottom: 40px; }
        
        .lobby-player {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 20px 40px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 2px solid #333;
        }
        
        .lobby-player.p1 { border-color: #ff6b35; }
        .lobby-player.p2 { border-color: #4361ee; }
        .lobby-player.connected { background: rgba(255, 255, 255, 0.1); }
        
        .lobby-player-icon { width: 60px; height: 60px; border-radius: 50%; background: #333; }
        .lobby-player.p1 .lobby-player-icon { background: #ff6b35; }
        .lobby-player.p2.connected .lobby-player-icon { background: #4361ee; }
        
        .lobby-player span { font-family: 'Bebas Neue', sans-serif; font-size: 20px; letter-spacing: 2px; color: #fff; }
        .ready-status { font-size: 14px !important; color: #888 !important; }
        .ready-status.ready { color: #10b981 !important; }
        
        .menu-controls { margin-top: 50px; color: #666; font-size: 14px; text-align: center; line-height: 2; }
        .menu-controls span { color: #ff6b35; font-weight: 600; }
        
        #cardSelect {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 90;
        }
        
        #cardSelect.active { display: flex; }
        
        .card-title { font-family: 'Bebas Neue', sans-serif; font-size: 48px; margin-bottom: 10px; letter-spacing: 6px; }
        .card-title.p1 { color: #ff6b35; }
        .card-title.p2 { color: #4361ee; }
        .card-subtitle { color: #888; margin-bottom: 40px; font-size: 18px; }
        
        .cards-container { display: flex; gap: 30px; perspective: 1000px; }
        
        .card {
            width: 220px; height: 300px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 16px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #333;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 6px;
            background: linear-gradient(90deg, #ff6b35, #e63946);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .card:hover { transform: translateY(-10px) rotateX(5deg); border-color: #ff6b35; box-shadow: 0 20px 40px rgba(255, 107, 53, 0.3); }
        .card:hover::before { opacity: 1; }
        
        .card-name { font-family: 'Bebas Neue', sans-serif; font-size: 26px; color: #fff; letter-spacing: 2px; margin-bottom: 10px; }
        .card-desc { color: #aaa; font-size: 13px; line-height: 1.5; flex: 1; }
        .card-stats { margin-top: 10px; padding-top: 10px; border-top: 1px solid #333; }
        .stat { font-size: 11px; margin: 3px 0; }
        .stat.positive { color: #4ade80; }
        .stat.negative { color: #f87171; }
        
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        #hud.active { display: block; }
        
        .player-hud { position: absolute; top: 20px; padding: 15px 25px; background: rgba(0, 0, 0, 0.7); border-radius: 12px; backdrop-filter: blur(10px); }
        .player-hud.p1 { left: 20px; border-left: 4px solid #ff6b35; }
        .player-hud.p2 { right: 20px; border-right: 4px solid #4361ee; }
        
        .player-name { font-family: 'Bebas Neue', sans-serif; font-size: 24px; letter-spacing: 3px; margin-bottom: 8px; }
        .player-name.p1 { color: #ff6b35; }
        .player-name.p2 { color: #4361ee; }
        
        .health-bar { width: 200px; height: 12px; background: #333; border-radius: 6px; overflow: hidden; margin-bottom: 8px; }
        .health-fill { height: 100%; transition: width 0.2s ease; border-radius: 6px; }
        .health-fill.p1 { background: linear-gradient(90deg, #ff6b35, #e63946); }
        .health-fill.p2 { background: linear-gradient(90deg, #4361ee, #3a0ca3); }
        
        .ammo-display { font-size: 14px; color: #888; }
        .ammo-display span { color: #fff; font-weight: 600; }
        
        .score-display { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 20px; font-family: 'Bebas Neue', sans-serif; font-size: 48px; }
        .score-p1 { color: #ff6b35; }
        .score-p2 { color: #4361ee; }
        .score-divider { color: #444; }
        
        #roundAnnounce {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 80px;
            color: #fff;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.5);
            letter-spacing: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        #roundAnnounce.show { opacity: 1; }
        
        #winnerScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 95;
        }
        
        #winnerScreen.active { display: flex; }
        
        .winner-text { font-family: 'Bebas Neue', sans-serif; font-size: 100px; letter-spacing: 10px; margin-bottom: 40px; }
        .winner-text.p1 { color: #ff6b35; text-shadow: 0 0 60px rgba(255, 107, 53, 0.8); }
        .winner-text.p2 { color: #4361ee; text-shadow: 0 0 60px rgba(67, 97, 238, 0.8); }
        
        .ping-display { position: absolute; bottom: 10px; right: 10px; color: #666; font-size: 12px; font-family: monospace; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="700"></canvas>
        
        <div id="mainMenu">
            <div class="menu-title">ROUNDS</div>
            <button class="menu-btn" onclick="startGame('local')">LOCAL MATCH</button>
            <button class="menu-btn secondary" onclick="startGame('ai')">VS AI</button>
            <button class="menu-btn online" onclick="showOnlineMenu()">ONLINE</button>
            <div class="menu-controls">
                <strong>PLAYER 1 (Orange)</strong><br>
                <span>WASD</span> - Move | <span>Left Click</span> - Shoot | <span>Right Click / F</span> - Block<br><br>
                <strong>PLAYER 2 (Blue)</strong><br>
                <span>Arrow Keys</span> - Move | <span>.</span> - Shoot | <span>/</span> - Block
            </div>
        </div>
        
        <div id="onlineMenu" class="hidden">
            <div class="menu-title" style="font-size: 80px;">ONLINE</div>
            <button class="menu-btn" onclick="createRoom()">CREATE ROOM</button>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin: 20px 0;">
                <input type="text" id="roomCodeInput" class="room-input" placeholder="CODE" maxlength="4">
                <button class="menu-btn secondary" onclick="joinRoom()">JOIN ROOM</button>
            </div>
            <button class="menu-btn back-btn" onclick="hideOnlineMenu()">BACK</button>
        </div>
        
        <div id="lobby" class="hidden">
            <div class="menu-title" style="font-size: 60px;">ROOM</div>
            <div class="room-code" id="displayRoomCode">XXXX</div>
            <div class="lobby-status" id="lobbyStatus">Waiting for opponent...</div>
            <div class="lobby-players">
                <div class="lobby-player p1 connected" id="lobbyP1">
                    <div class="lobby-player-icon"></div>
                    <span>PLAYER 1</span>
                    <span class="ready-status" id="p1Ready">NOT READY</span>
                </div>
                <div class="lobby-player p2" id="lobbyP2">
                    <div class="lobby-player-icon"></div>
                    <span>PLAYER 2</span>
                    <span class="ready-status" id="p2Ready">WAITING...</span>
                </div>
            </div>
            <button class="menu-btn" id="readyBtn" onclick="toggleReady()">READY</button>
            <button class="menu-btn back-btn" onclick="leaveLobby()">LEAVE</button>
        </div>
        
        <div id="cardSelect">
            <div class="card-title p1" id="cardPlayerTitle">PLAYER 1 - PICK A CARD</div>
            <div class="card-subtitle">Choose your upgrade</div>
            <div class="cards-container" id="cardsContainer"></div>
        </div>
        
        <div id="hud">
            <div class="player-hud p1">
                <div class="player-name p1">PLAYER 1</div>
                <div class="health-bar"><div class="health-fill p1" id="health1"></div></div>
                <div class="ammo-display">AMMO: <span id="ammo1">3/3</span></div>
            </div>
            <div class="player-hud p2">
                <div class="player-name p2">PLAYER 2</div>
                <div class="health-bar"><div class="health-fill p2" id="health2"></div></div>
                <div class="ammo-display">AMMO: <span id="ammo2">3/3</span></div>
            </div>
            <div class="score-display">
                <span class="score-p1" id="score1">0</span>
                <span class="score-divider">-</span>
                <span class="score-p2" id="score2">0</span>
            </div>
            <div class="ping-display" id="pingDisplay"></div>
        </div>
        
        <div id="roundAnnounce"></div>
        
        <div id="winnerScreen">
            <div class="winner-text" id="winnerText">PLAYER 1 WINS</div>
            <button class="menu-btn" onclick="returnToMenu()">MAIN MENU</button>
            <button class="menu-btn secondary" onclick="rematch()">REMATCH</button>
        </div>
    </div>

    <script>
    // ==================== CANVAS & CONSTANTS ====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GRAVITY = 0.5, FRICTION = 0.92;
    
    // ==================== GAME STATE ====================
    let gameMode = 'local', gameState = 'menu', currentRound = 1;
    let player1, player2, bullets = [], explosions = [], particles = [];
    let keys = {}, mouse = { x: 600, y: 350 };
    
    // ==================== ONLINE STATE (OPTIMIZED) ====================
    let roomCode = null, playerId = null, roomRef = null, isHost = false, isReady = false;
    let lastSyncTime = 0, pingStart = 0, currentPing = 0;
    const SYNC_RATE = 50; // 20 updates/sec instead of 30
    
    // Interpolation for smooth opponent movement
    let opponentState = { x: 0, y: 0, vx: 0, vy: 0, timestamp: 0 };
    let opponentPrevState = { x: 0, y: 0, vx: 0, vy: 0, timestamp: 0 };
    const INTERPOLATION_DELAY = 100; // ms
    
    // Input buffer for network - only send changes
    let lastSentInput = { left: false, right: false, up: false };
    let pendingBullets = [];
    
    // ==================== MAPS ====================
    const MAPS = [
        { name: "Classic", bg: '#0a0a0f', plat: '#1a1a2e', hi: '#2a2a4e', platforms: [
            {x:0,y:650,w:1200,h:50},{x:100,y:520,w:200,h:20},{x:900,y:520,w:200,h:20},
            {x:450,y:450,w:300,h:20},{x:50,y:350,w:150,h:20},{x:1000,y:350,w:150,h:20},
            {x:500,y:280,w:200,h:20},{x:200,y:200,w:150,h:20},{x:850,y:200,w:150,h:20}
        ]},
        { name: "Neon", bg: '#0d0221', plat: '#541388', hi: '#ff00ff', platforms: [
            {x:0,y:650,w:1200,h:50},{x:50,y:500,w:150,h:15},{x:250,y:400,w:150,h:15},
            {x:500,y:550,w:200,h:15},{x:800,y:400,w:150,h:15},{x:1000,y:500,w:150,h:15},
            {x:400,y:300,w:100,h:15},{x:700,y:300,w:100,h:15},{x:550,y:180,w:100,h:15}
        ]},
        { name: "Lava", bg: '#1a0a0a', plat: '#4a1a1a', hi: '#ff4400', platforms: [
            {x:0,y:650,w:400,h:50},{x:800,y:650,w:400,h:50},{x:450,y:600,w:300,h:20},
            {x:100,y:480,w:180,h:20},{x:920,y:480,w:180,h:20},{x:350,y:400,w:150,h:20},
            {x:700,y:400,w:150,h:20},{x:500,y:300,w:200,h:20},{x:550,y:150,w:100,h:20}
        ]}
    ];
    let currentMap = MAPS[0], platforms = currentMap.platforms;
    
    // ==================== CARDS ====================
    const CARDS = [
        { name: "Big Bullet", desc: "Bigger bullets", stats: ["+50% size","+0.25s reload"], effect: p => { p.bulletSize *= 1.5; p.reloadTime += 0.25; }},
        { name: "Barrage", desc: "Fire many bullets", stats: ["+4 bullets","-70% dmg"], effect: p => { p.bulletsPerShot += 4; p.maxAmmo += 5; p.damage *= 0.3; }},
        { name: "Bouncy", desc: "Bullets bounce", stats: ["+2 bounces"], effect: p => { p.bulletBounces += 2; p.damage *= 1.25; }},
        { name: "Homing", desc: "Seek enemies", stats: ["Homing","-25% dmg"], effect: p => { p.homing = true; p.damage *= 0.75; }},
        { name: "Explosive", desc: "Explode on hit", stats: ["Explosive"], effect: p => { p.explosive = true; p.fireRate *= 1.5; }},
        { name: "Quick Reload", desc: "Fast reload", stats: ["-70% reload"], effect: p => { p.reloadTime *= 0.3; }},
        { name: "Tank", desc: "More HP", stats: ["+100% HP"], effect: p => { p.maxHealth *= 2; p.health = p.maxHealth; }},
        { name: "Glass Cannon", desc: "High risk", stats: ["+100% dmg","-50% HP"], effect: p => { p.damage *= 2; p.maxHealth *= 0.5; p.health = Math.min(p.health, p.maxHealth); }},
        { name: "Spray", desc: "Bullet hose", stats: ["+500% fire rate","-75% dmg"], effect: p => { p.fireRate *= 0.2; p.maxAmmo += 12; p.damage *= 0.25; }},
        { name: "Fastball", desc: "Fast bullets", stats: ["+150% speed"], effect: p => { p.bulletSpeed *= 2.5; }},
        { name: "Buckshot", desc: "Shotgun", stats: ["+4 bullets","spread"], effect: p => { p.bulletsPerShot += 4; p.spread = 0.4; p.damage *= 0.4; }},
        { name: "Leech", desc: "Life steal", stats: ["+50% steal"], effect: p => { p.lifeSteal = 0.5; p.maxHealth *= 1.3; p.health = p.maxHealth; }}
    ];
    
    // ==================== PLAYER CLASS ====================
    class Player {
        constructor(x, y, color, controls, id) {
            this.id = id; this.x = x; this.y = y; this.spawnX = x; this.spawnY = y;
            this.vx = 0; this.vy = 0; this.radius = 25; this.color = color; this.controls = controls;
            this.maxHealth = 100; this.health = 100; this.damage = 25; this.bulletSpeed = 15;
            this.bulletSize = 8; this.fireRate = 0.3; this.reloadTime = 1.5; this.maxAmmo = 3;
            this.ammo = 3; this.bulletsPerShot = 1; this.bulletBounces = 0; this.spread = 0.05;
            this.blockCooldown = 2; this.homing = false; this.explosive = false; this.lifeSteal = 0;
            this.grounded = false; this.facingRight = id === 1; this.lastShot = 0;
            this.reloading = false; this.reloadStart = 0; this.blocking = false;
            this.blockTime = 0; this.lastBlock = -10; this.cards = []; this.score = 0;
            this.legPhase = 0; this.leftLeg = { angle: 0 }; this.rightLeg = { angle: 0 };
        }
        
        reset() {
            this.x = this.spawnX; this.y = this.spawnY; this.vx = 0; this.vy = 0;
            this.health = this.maxHealth; this.ammo = this.maxAmmo; this.reloading = false;
            this.blocking = false; this.lastShot = 0; this.lastBlock = -10;
        }
        
        fullReset() {
            this.radius = 25; this.maxHealth = 100; this.health = 100; this.damage = 25;
            this.bulletSpeed = 15; this.bulletSize = 8; this.fireRate = 0.3; this.reloadTime = 1.5;
            this.maxAmmo = 3; this.ammo = 3; this.bulletsPerShot = 1; this.bulletBounces = 0;
            this.spread = 0.05; this.blockCooldown = 2; this.homing = false; this.explosive = false;
            this.lifeSteal = 0; this.cards = []; this.score = 0; this.reset();
        }
        
        update(inputKeys, other, now) {
            const moveSpeed = 0.6, jumpForce = -14;
            
            if (inputKeys[this.controls.left]) { this.vx -= moveSpeed; this.facingRight = false; }
            if (inputKeys[this.controls.right]) { this.vx += moveSpeed; this.facingRight = true; }
            if (inputKeys[this.controls.up] && this.grounded) { this.vy = jumpForce; this.grounded = false; }
            
            this.vy += GRAVITY;
            this.vx *= FRICTION;
            this.x += this.vx;
            this.y += this.vy;
            
            // Collision
            this.grounded = false;
            const feetOffset = this.radius * 0.5 + 35;
            
            for (const p of platforms) {
                if (this.x + this.radius > p.x && this.x - this.radius < p.x + p.w &&
                    this.y + feetOffset > p.y && this.y - this.radius < p.y + p.h) {
                    if (this.vy > 0 && this.y + feetOffset - this.vy <= p.y + 5) {
                        this.y = p.y - feetOffset; this.vy = 0; this.grounded = true;
                    } else if (this.vy < 0 && this.y - this.radius - this.vy >= p.y + p.h - 5) {
                        this.y = p.y + p.h + this.radius; this.vy = 0;
                    } else if (this.vx > 0) { this.x = p.x - this.radius; this.vx = 0; }
                    else if (this.vx < 0) { this.x = p.x + p.w + this.radius; this.vx = 0; }
                }
            }
            
            // Bounds
            if (this.x < this.radius) { this.x = this.radius; this.vx = 0; }
            if (this.x > canvas.width - this.radius) { this.x = canvas.width - this.radius; this.vx = 0; }
            if (this.y < this.radius) { this.y = this.radius; this.vy = 0; }
            if (this.y + feetOffset > canvas.height) { this.y = canvas.height - feetOffset; this.vy = 0; this.grounded = true; }
            
            // Reload
            if (this.reloading && now - this.reloadStart >= this.reloadTime * 1000) {
                this.ammo = this.maxAmmo; this.reloading = false;
            }
            if (this.ammo <= 0 && !this.reloading) { this.reloading = true; this.reloadStart = now; }
            if (this.blocking && now - this.blockTime > 200) this.blocking = false;
            
            // Legs
            const speed = Math.abs(this.vx);
            if (speed > 0.5 && this.grounded) {
                this.legPhase += speed * 0.15;
                this.leftLeg.angle = Math.sin(this.legPhase) * 0.6;
                this.rightLeg.angle = Math.sin(this.legPhase + Math.PI) * 0.6;
            } else if (!this.grounded) {
                this.leftLeg.angle = 0.3 + this.vy * 0.02;
                this.rightLeg.angle = 0.2 + this.vy * 0.02;
            } else {
                this.leftLeg.angle *= 0.9; this.rightLeg.angle *= 0.9;
            }
        }
        
        shoot(other, now, mouseTarget = null) {
            if (this.ammo <= 0 || this.reloading || now - this.lastShot < this.fireRate * 1000) return [];
            this.lastShot = now; this.ammo--;
            
            const newBullets = [];
            let baseAngle = mouseTarget ? Math.atan2(mouseTarget.y - this.y, mouseTarget.x - this.x) : (this.facingRight ? 0 : Math.PI);
            if (mouseTarget) this.facingRight = mouseTarget.x > this.x;
            
            for (let i = 0; i < this.bulletsPerShot; i++) {
                let angle = baseAngle;
                if (this.bulletsPerShot > 1) angle += (i / (this.bulletsPerShot - 1) - 0.5) * this.spread * 2;
                angle += (Math.random() - 0.5) * this.spread;
                
                newBullets.push(new Bullet(
                    this.x + Math.cos(baseAngle) * (this.radius + 5),
                    this.y + Math.sin(baseAngle) * (this.radius + 5),
                    Math.cos(angle) * this.bulletSpeed,
                    Math.sin(angle) * this.bulletSpeed,
                    this
                ));
            }
            return newBullets;
        }
        
        block(other, now) {
            if (now - this.lastBlock < this.blockCooldown * 1000) return;
            this.blocking = true; this.blockTime = now; this.lastBlock = now;
        }
        
        takeDamage(amount, source) {
            if (this.blocking) return false;
            this.health -= amount;
            if (source?.owner?.lifeSteal > 0) {
                source.owner.health = Math.min(source.owner.maxHealth, source.owner.health + amount * source.owner.lifeSteal);
            }
            return true;
        }
        
        draw(mousePos = null) {
            ctx.save();
            
            // Shield
            if (this.blocking) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 15, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.globalAlpha = 0.6;
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
            
            // Legs
            const legLength = 35, legAttachY = this.y + this.radius * 0.5;
            ctx.lineCap = 'round'; ctx.lineWidth = 3; ctx.strokeStyle = this.color;
            
            ctx.save();
            ctx.translate(this.x - 8, legAttachY);
            ctx.rotate(this.leftLeg.angle);
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, legLength); ctx.stroke();
            ctx.beginPath(); ctx.ellipse(0, legLength, 5, 3, 0, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill();
            ctx.restore();
            
            ctx.save();
            ctx.translate(this.x + 8, legAttachY);
            ctx.rotate(this.rightLeg.angle);
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, legLength); ctx.stroke();
            ctx.beginPath(); ctx.ellipse(0, legLength, 5, 3, 0, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill();
            ctx.restore();
            
            // Body
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // Gun angle
            let gunAngle = mousePos && this.id === 1 ? Math.atan2(mousePos.y - this.y, mousePos.x - this.x) : (this.facingRight ? 0 : Math.PI);
            
            // Eye
            const eyeX = this.x + Math.cos(gunAngle) * 8;
            ctx.beginPath(); ctx.arc(eyeX, this.y - 5, 5, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX + Math.cos(gunAngle) * 2, this.y - 5 + Math.sin(gunAngle) * 2, 2, 0, Math.PI * 2);
            ctx.fillStyle = '#000'; ctx.fill();
            
            // Gun
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(gunAngle);
            ctx.fillStyle = '#333';
            ctx.fillRect(this.radius - 5, -4, 25, 8);
            ctx.restore();
            
            // Health bar
            const barW = 50, barH = 6, barX = this.x - barW / 2, barY = this.y - this.radius - 15;
            ctx.fillStyle = '#333'; ctx.fillRect(barX, barY, barW, barH);
            ctx.fillStyle = this.color; ctx.fillRect(barX, barY, barW * (this.health / this.maxHealth), barH);
            
            // Reload indicator
            if (this.reloading) {
                const progress = (Date.now() - this.reloadStart) / (this.reloadTime * 1000);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 10, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * progress);
                ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 3; ctx.stroke();
            }
            
            ctx.restore();
        }
    }
    
    // ==================== BULLET CLASS ====================
    class Bullet {
        constructor(x, y, vx, vy, owner) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.owner = owner;
            this.radius = owner.bulletSize; this.damage = owner.damage;
            this.bouncesLeft = owner.bulletBounces; this.homing = owner.homing;
            this.explosive = owner.explosive; this.alive = true;
        }
        
        update(target) {
            if (this.homing && target) {
                const dx = target.x - this.x, dy = target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    this.vx += (dx / dist) * 0.5; this.vy += (dy / dist) * 0.5;
                    const newSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    this.vx = (this.vx / newSpeed) * speed; this.vy = (this.vy / newSpeed) * speed;
                }
            }
            
            this.vy += 0.1;
            this.x += this.vx; this.y += this.vy;
            
            // Wall collision
            if (this.x < this.radius || this.x > canvas.width - this.radius) {
                if (this.bouncesLeft > 0) { this.vx *= -1; this.bouncesLeft--; this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x)); }
                else this.alive = false;
            }
            if (this.y < this.radius || this.y > canvas.height - this.radius) {
                if (this.bouncesLeft > 0) { this.vy *= -1; this.bouncesLeft--; this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y)); }
                else this.alive = false;
            }
            
            // Platform collision
            for (const p of platforms) {
                if (this.x + this.radius > p.x && this.x - this.radius < p.x + p.w &&
                    this.y + this.radius > p.y && this.y - this.radius < p.y + p.h) {
                    if (this.bouncesLeft > 0) {
                        const oL = this.x + this.radius - p.x, oR = p.x + p.w - this.x + this.radius;
                        const oT = this.y + this.radius - p.y, oB = p.y + p.h - this.y + this.radius;
                        if (Math.min(oT, oB) < Math.min(oL, oR)) this.vy *= -1; else this.vx *= -1;
                        this.bouncesLeft--;
                    } else this.alive = false;
                    break;
                }
            }
        }
        
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.explosive ? '#ff4444' : this.homing ? '#ff44ff' : this.owner.color;
            ctx.fill();
            
            // Trail
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x - this.vx * 2, this.y - this.vy * 2);
            ctx.strokeStyle = this.owner.color;
            ctx.lineWidth = this.radius * 0.8;
            ctx.globalAlpha = 0.5; ctx.stroke(); ctx.globalAlpha = 1;
        }
    }
    
    // ==================== EXPLOSION CLASS ====================
    class Explosion {
        constructor(x, y, radius, damage, owner) {
            this.x = x; this.y = y; this.radius = radius; this.damage = damage;
            this.owner = owner; this.time = 0; this.maxTime = 20;
        }
        update() { return ++this.time < this.maxTime; }
        draw() {
            const p = this.time / this.maxTime;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * (0.5 + p * 0.5), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 100, 50, ${1 - p})`; ctx.fill();
        }
    }
    
    // ==================== ONLINE NETWORKING (OPTIMIZED) ====================
    function generateRoomCode() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        return Array(4).fill().map(() => chars[Math.floor(Math.random() * chars.length)]).join('');
    }
    
    function showOnlineMenu() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('onlineMenu').classList.remove('hidden');
    }
    
    function hideOnlineMenu() {
        document.getElementById('onlineMenu').classList.add('hidden');
        document.getElementById('mainMenu').classList.remove('hidden');
    }
    
    async function createRoom() {
        roomCode = generateRoomCode();
        isHost = true; playerId = 1;
        currentMap = MAPS[Math.floor(Math.random() * MAPS.length)];
        platforms = currentMap.platforms;
        
        roomRef = database.ref('rooms/' + roomCode);
        await roomRef.set({
            mapIndex: MAPS.indexOf(currentMap),
            state: 'waiting',
            p1: { ready: false, connected: true },
            round: 1, s1: 0, s2: 0
        });
        
        roomRef.onDisconnect().remove();
        setupRoomListeners();
        showLobby();
    }
    
    async function joinRoom() {
        const code = document.getElementById('roomCodeInput').value.toUpperCase().trim();
        if (code.length !== 4) { alert('Enter a valid 4-character code'); return; }
        
        roomCode = code; isHost = false; playerId = 2;
        roomRef = database.ref('rooms/' + roomCode);
        
        const snapshot = await roomRef.once('value');
        if (!snapshot.exists()) { alert('Room not found!'); return; }
        
        const data = snapshot.val();
        if (data.p2?.connected) { alert('Room is full!'); return; }
        
        currentMap = MAPS[data.mapIndex];
        platforms = currentMap.platforms;
        
        await roomRef.child('p2').set({ ready: false, connected: true });
        roomRef.child('p2').onDisconnect().remove();
        
        setupRoomListeners();
        showLobby();
    }
    
    function setupRoomListeners() {
        // Compact player state listener
        roomRef.on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            
            // Lobby updates
            const p1c = data.p1?.connected, p2c = data.p2?.connected;
            document.getElementById('lobbyP1').classList.toggle('connected', p1c);
            document.getElementById('lobbyP2').classList.toggle('connected', p2c);
            
            const p1r = document.getElementById('p1Ready'), p2r = document.getElementById('p2Ready');
            p1r.textContent = data.p1?.ready ? 'READY' : 'NOT READY';
            p1r.classList.toggle('ready', data.p1?.ready);
            p2r.textContent = p2c ? (data.p2?.ready ? 'READY' : 'NOT READY') : 'WAITING...';
            p2r.classList.toggle('ready', data.p2?.ready);
            document.getElementById('lobbyStatus').textContent = p2c ? 'Opponent connected!' : 'Waiting for opponent...';
            
            if (data.p1?.ready && data.p2?.ready && data.state === 'waiting') {
                if (isHost) roomRef.child('state').set('starting');
            }
            
            if (data.state === 'starting' && gameState === 'menu') startOnlineGame();
            
            // Game state sync
            if (gameState === 'playing' && data.g) {
                const oppId = playerId === 1 ? 2 : 1;
                const oppData = data.g['p' + oppId];
                if (oppData && oppData.t > opponentState.timestamp) {
                    opponentPrevState = { ...opponentState };
                    opponentState = { x: oppData.x, y: oppData.y, vx: oppData.vx, vy: oppData.vy, h: oppData.h, timestamp: oppData.t };
                }
            }
            
            // Score sync
            if (data.s1 !== undefined) { player1.score = data.s1; player2.score = data.s2; }
        });
        
        // Bullet listener - use child_added for efficiency
        roomRef.child('b').on('child_added', snapshot => {
            const b = snapshot.val();
            if (!b || b.o === playerId || gameState !== 'playing') return;
            
            const owner = b.o === 1 ? player1 : player2;
            bullets.push(new Bullet(b.x, b.y, b.vx, b.vy, owner));
            snapshot.ref.remove();
        });
        
        // Card pick listener
        roomRef.child('card').on('value', snapshot => {
            const pick = snapshot.val();
            if (!pick || pick.p === playerId) return;
            
            const opponent = pick.p === 1 ? player1 : player2;
            const card = CARDS.find(c => c.name === pick.n);
            if (card) { card.effect(opponent); opponent.cards.push(card.name); opponent.ammo = opponent.maxAmmo; }
        });
    }
    
    function showLobby() {
        document.getElementById('onlineMenu').classList.add('hidden');
        document.getElementById('lobby').classList.remove('hidden');
        document.getElementById('displayRoomCode').textContent = roomCode;
        isReady = false;
        document.getElementById('readyBtn').textContent = 'READY';
    }
    
    function toggleReady() {
        isReady = !isReady;
        document.getElementById('readyBtn').textContent = isReady ? 'NOT READY' : 'READY';
        roomRef.child('p' + playerId + '/ready').set(isReady);
    }
    
    function leaveLobby() {
        if (roomRef) {
            roomRef.child('p' + playerId).remove();
            if (isHost) roomRef.remove();
            roomRef.off(); roomRef = null;
        }
        roomCode = null; playerId = null; isHost = false; isReady = false;
        document.getElementById('lobby').classList.add('hidden');
        document.getElementById('mainMenu').classList.remove('hidden');
    }
    
    function startOnlineGame() {
        document.getElementById('lobby').classList.add('hidden');
        gameMode = 'online';
        initPlayers();
        currentRound = 1; player1.score = 0; player2.score = 0;
        updateHUD();
        startRound();
    }
    
    // Optimized sync - only send when needed, minimal data
    function syncPlayerState() {
        if (gameMode !== 'online' || !roomRef || gameState !== 'playing') return;
        
        const now = Date.now();
        if (now - lastSyncTime < SYNC_RATE) return;
        lastSyncTime = now;
        
        const p = playerId === 1 ? player1 : player2;
        
        // Compact data structure
        roomRef.child('g/p' + playerId).set({
            x: Math.round(p.x), y: Math.round(p.y),
            vx: Math.round(p.vx * 10) / 10, vy: Math.round(p.vy * 10) / 10,
            h: Math.round(p.health), t: now
        });
        
        // Ping calculation
        pingStart = now;
    }
    
    function sendBullet(bullet) {
        if (gameMode !== 'online' || !roomRef) return;
        roomRef.child('b').push({
            o: playerId,
            x: Math.round(bullet.x), y: Math.round(bullet.y),
            vx: Math.round(bullet.vx * 10) / 10, vy: Math.round(bullet.vy * 10) / 10
        });
    }
    
    // Interpolate opponent position for smooth movement
    function interpolateOpponent() {
        if (gameMode !== 'online' || gameState !== 'playing') return;
        
        const opponent = playerId === 1 ? player2 : player1;
        const now = Date.now();
        const renderTime = now - INTERPOLATION_DELAY;
        
        if (opponentState.timestamp > opponentPrevState.timestamp) {
            const dt = opponentState.timestamp - opponentPrevState.timestamp;
            const t = Math.min(1, Math.max(0, (renderTime - opponentPrevState.timestamp) / dt));
            
            // Lerp position
            opponent.x = opponentPrevState.x + (opponentState.x - opponentPrevState.x) * t;
            opponent.y = opponentPrevState.y + (opponentState.y - opponentPrevState.y) * t;
            opponent.vx = opponentState.vx;
            opponent.vy = opponentState.vy;
            if (opponentState.h !== undefined) opponent.health = opponentState.h;
        }
    }
    
    // ==================== AI ====================
    let aiState = 'approach', aiStateTime = 0;
    
    function updateAI(now) {
        if (gameMode !== 'ai') return;
        
        const ai = player2, target = player1;
        aiStateTime++;
        
        const dx = target.x - ai.x, dy = target.y - ai.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Check incoming bullets
        for (const b of bullets) {
            if (b.owner !== ai && Math.sqrt((b.x - ai.x) ** 2 + (b.y - ai.y) ** 2) < 150 && Math.random() < 0.05) {
                ai.block(target, now);
            }
        }
        
        // Movement
        if (dist > 400 || aiState === 'approach') {
            if (dx > 50) keys['ArrowRight'] = true;
            else if (dx < -50) keys['ArrowLeft'] = true;
            if (aiStateTime > 60) { aiState = Math.random() < 0.5 ? 'strafe' : 'attack'; aiStateTime = 0; }
        } else if (aiState === 'strafe') {
            keys[Math.random() < 0.5 ? 'ArrowLeft' : 'ArrowRight'] = true;
            if (aiStateTime > 30) { aiState = 'attack'; aiStateTime = 0; }
        } else if (aiState === 'attack') {
            ai.facingRight = dx > 0;
            if (Math.random() < 0.1 && dist < 500) bullets.push(...ai.shoot(target, now));
            if (aiStateTime > 40) { aiState = Math.random() < 0.3 ? 'retreat' : 'approach'; aiStateTime = 0; }
        } else if (aiState === 'retreat') {
            if (dx > 0) keys['ArrowLeft'] = true; else keys['ArrowRight'] = true;
            if (aiStateTime > 30) { aiState = 'approach'; aiStateTime = 0; }
        }
        
        if (Math.random() < 0.02 && ai.grounded) keys['ArrowUp'] = true;
        if (dy < -100 && ai.grounded && Math.random() < 0.05) keys['ArrowUp'] = true;
    }
    
    function clearAIKeys() {
        if (gameMode === 'ai') { delete keys['ArrowLeft']; delete keys['ArrowRight']; delete keys['ArrowUp']; }
    }
    
    // ==================== GAME FLOW ====================
    function initPlayers() {
        player1 = new Player(200, 460, '#ff6b35', { left: 'KeyA', right: 'KeyD', up: 'KeyW' }, 1);
        player2 = new Player(1000, 460, '#4361ee', { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp' }, 2);
    }
    
    function startGame(mode) {
        gameMode = mode;
        document.getElementById('mainMenu').classList.add('hidden');
        currentMap = MAPS[Math.floor(Math.random() * MAPS.length)];
        platforms = currentMap.platforms;
        initPlayers();
        currentRound = 1; player1.score = 0; player2.score = 0;
        updateHUD();
        startRound();
    }
    
    function startRound() {
        gameState = 'roundStart';
        bullets = []; explosions = [];
        player1.reset(); player2.reset();
        
        document.getElementById('hud').classList.add('active');
        const announce = document.getElementById('roundAnnounce');
        announce.innerHTML = `ROUND ${currentRound}<br><span style="font-size:32px;color:${currentMap.hi}">${currentMap.name.toUpperCase()}</span>`;
        announce.classList.add('show');
        
        setTimeout(() => { announce.textContent = 'FIGHT!'; }, 1200);
        setTimeout(() => { announce.classList.remove('show'); gameState = 'playing'; }, 1700);
    }
    
    function endRound(winner) {
        gameState = 'roundEnd';
        if (winner === 1) player1.score++; else player2.score++;
        
        if (gameMode === 'online' && isHost) {
            roomRef.update({ s1: player1.score, s2: player2.score });
        }
        
        updateHUD();
        
        if (player1.score >= 3 || player2.score >= 3) {
            setTimeout(() => showWinner(player1.score >= 3 ? 1 : 2), 1000);
        } else {
            const announce = document.getElementById('roundAnnounce');
            announce.textContent = `PLAYER ${winner} WINS`;
            announce.classList.add('show');
            
            setTimeout(() => {
                announce.classList.remove('show');
                currentRound++;
                
                if (gameMode === 'online') {
                    if (winner === playerId) showCardSelect(playerId);
                    else {
                        announce.textContent = 'OPPONENT PICKING...';
                        announce.classList.add('show');
                        const cardUnsub = roomRef.child('card').on('value', snap => {
                            const pick = snap.val();
                            if (pick && pick.p === winner) {
                                roomRef.child('card').off('value', cardUnsub);
                                announce.classList.remove('show');
                                startRound();
                            }
                        });
                    }
                } else if (gameMode === 'ai' && winner === 2) {
                    const card = CARDS[Math.floor(Math.random() * CARDS.length)];
                    card.effect(player2); player2.cards.push(card.name); player2.ammo = player2.maxAmmo;
                    startRound();
                } else {
                    showCardSelect(winner);
                }
            }, 1500);
        }
    }
    
    function showCardSelect(playerNum) {
        const cardSelect = document.getElementById('cardSelect');
        const title = document.getElementById('cardPlayerTitle');
        const container = document.getElementById('cardsContainer');
        
        title.textContent = `PLAYER ${playerNum} - PICK A CARD`;
        title.className = `card-title p${playerNum}`;
        
        const choices = [...CARDS].sort(() => Math.random() - 0.5).slice(0, 3);
        
        container.innerHTML = '';
        choices.forEach(card => {
            const el = document.createElement('div');
            el.className = 'card';
            el.innerHTML = `
                <div class="card-name">${card.name}</div>
                <div class="card-desc">${card.desc}</div>
                <div class="card-stats">${card.stats.map(s => `<div class="stat ${s.startsWith('+') || !s.startsWith('-') ? 'positive' : 'negative'}">${s}</div>`).join('')}</div>
            `;
            el.onclick = () => selectCard(card, playerNum);
            container.appendChild(el);
        });
        
        cardSelect.classList.add('active');
        gameState = 'cardSelect';
    }
    
    function selectCard(card, playerNum) {
        const player = playerNum === 1 ? player1 : player2;
        card.effect(player);
        player.cards.push(card.name);
        player.ammo = player.maxAmmo;
        
        document.getElementById('cardSelect').classList.remove('active');
        
        if (gameMode === 'online') {
            roomRef.child('card').set({ p: playerId, n: card.name, t: Date.now() });
            startRound();
        } else if (playerNum === 1 && gameMode === 'local') {
            setTimeout(() => showCardSelect(2), 300);
        } else {
            startRound();
        }
    }
    
    function showWinner(winner) {
        gameState = 'gameOver';
        const screen = document.getElementById('winnerScreen');
        const text = document.getElementById('winnerText');
        text.textContent = `PLAYER ${winner} WINS!`;
        text.className = `winner-text p${winner}`;
        screen.classList.add('active');
        document.getElementById('hud').classList.remove('active');
    }
    
    function returnToMenu() {
        document.getElementById('winnerScreen').classList.remove('active');
        document.getElementById('mainMenu').classList.remove('hidden');
        
        if (gameMode === 'online' && roomRef) {
            roomRef.child('p' + playerId).remove();
            if (isHost) roomRef.remove();
            roomRef.off(); roomRef = null;
            roomCode = null; playerId = null; isHost = false;
        }
        gameState = 'menu';
    }
    
    function rematch() {
        document.getElementById('winnerScreen').classList.remove('active');
        currentMap = MAPS[Math.floor(Math.random() * MAPS.length)];
        platforms = currentMap.platforms;
        player1.fullReset(); player2.fullReset();
        currentRound = 1;
        updateHUD();
        startRound();
    }
    
    function updateHUD() {
        document.getElementById('health1').style.width = `${(player1.health / player1.maxHealth) * 100}%`;
        document.getElementById('health2').style.width = `${(player2.health / player2.maxHealth) * 100}%`;
        document.getElementById('ammo1').textContent = `${player1.ammo}/${player1.maxAmmo}`;
        document.getElementById('ammo2').textContent = `${player2.ammo}/${player2.maxAmmo}`;
        document.getElementById('score1').textContent = player1.score;
        document.getElementById('score2').textContent = player2.score;
        
        if (gameMode === 'online') {
            document.getElementById('pingDisplay').textContent = `PING: ${currentPing}ms`;
        }
    }
    
    // ==================== INPUT ====================
    document.addEventListener('keydown', e => {
        keys[e.code] = true;
        
        if (gameState === 'playing') {
            const now = Date.now();
            if (gameMode === 'online') {
                if (e.code === 'KeyF') {
                    const local = playerId === 1 ? player1 : player2;
                    local.block(playerId === 1 ? player2 : player1, now);
                }
            } else {
                if (e.code === 'KeyF') player1.block(player2, now);
                if (gameMode === 'local') {
                    if (e.code === 'Period') bullets.push(...player2.shoot(player1, now));
                    if (e.code === 'Slash') player2.block(player1, now);
                }
            }
        }
    });
    
    document.addEventListener('keyup', e => { keys[e.code] = false; });
    
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
    });
    
    canvas.addEventListener('mousedown', e => {
        if (gameState === 'playing' && e.button === 0) {
            const now = Date.now();
            if (gameMode === 'online') {
                const local = playerId === 1 ? player1 : player2;
                const newBullets = local.shoot(playerId === 1 ? player2 : player1, now, mouse);
                bullets.push(...newBullets);
                newBullets.forEach(b => sendBullet(b));
            } else {
                bullets.push(...player1.shoot(player2, now, mouse));
            }
        }
    });
    
    canvas.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (gameState === 'playing') {
            const now = Date.now();
            if (gameMode === 'online') {
                const local = playerId === 1 ? player1 : player2;
                local.block(playerId === 1 ? player2 : player1, now);
            } else {
                player1.block(player2, now);
            }
        }
    });
    
    // ==================== GAME LOOP ====================
    function gameLoop() {
        const now = Date.now();
        
        // Clear & draw background
        ctx.fillStyle = currentMap.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw platforms
        for (const p of platforms) {
            ctx.fillStyle = currentMap.plat;
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = currentMap.hi;
            ctx.fillRect(p.x, p.y, p.w, 3);
        }
        
        if (gameState === 'playing') {
            clearAIKeys();
            updateAI(now);
            
            // Update players
            if (gameMode === 'online') {
                const local = playerId === 1 ? player1 : player2;
                const opponent = playerId === 1 ? player2 : player1;
                
                const inputKeys = {
                    [local.controls.left]: keys['KeyA'],
                    [local.controls.right]: keys['KeyD'],
                    [local.controls.up]: keys['KeyW']
                };
                
                local.update(inputKeys, opponent, now);
                interpolateOpponent(); // Smooth opponent movement
                syncPlayerState();
            } else {
                player1.update(keys, player2, now);
                player2.update(keys, player1, now);
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                const target = b.owner === player1 ? player2 : player1;
                b.update(target);
                
                if (!b.alive) { bullets.splice(i, 1); continue; }
                
                // Hit detection
                const dx = b.x - target.x, dy = b.y - target.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < b.radius + target.radius) {
                    if (!target.blocking) {
                        target.takeDamage(b.damage, b);
                        if (b.explosive) explosions.push(new Explosion(b.x, b.y, 80, b.damage * 0.5, b.owner));
                    }
                    bullets.splice(i, 1);
                }
            }
            
            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) explosions.splice(i, 1);
            }
            
            // Check round end
            if (player1.health <= 0) endRound(2);
            else if (player2.health <= 0) endRound(1);
            
            updateHUD();
        }
        
        // Draw game objects
        if (gameState !== 'menu') {
            explosions.forEach(e => e.draw());
            bullets.forEach(b => b.draw());
            
            if (gameMode === 'online') {
                if (playerId === 1) { player1.draw(mouse); player2.draw(); }
                else { player1.draw(); player2.draw(mouse); }
            } else {
                player1.draw(mouse); player2.draw();
            }
            
            // Crosshair
            if (gameState === 'playing') {
                ctx.save();
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, 15, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(mouse.x - 20, mouse.y); ctx.lineTo(mouse.x - 8, mouse.y);
                ctx.moveTo(mouse.x + 8, mouse.y); ctx.lineTo(mouse.x + 20, mouse.y);
                ctx.moveTo(mouse.x, mouse.y - 20); ctx.lineTo(mouse.x, mouse.y - 8);
                ctx.moveTo(mouse.x, mouse.y + 8); ctx.lineTo(mouse.x, mouse.y + 20);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = '#ff6b35';
                ctx.fill();
                ctx.restore();
            }
        }
        
        requestAnimationFrame(gameLoop);
    }
    
    gameLoop();
    </script>
</body>
</html>