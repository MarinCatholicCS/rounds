<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Void Space</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; touch-action: none; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        canvas { display: block; }
        .ui-overlay { position: fixed; z-index: 100; pointer-events: none; }
        .ui-overlay * { pointer-events: auto; }
        .header { top: 0; left: 0; right: 0; padding: 20px 30px; display: flex; justify-content: space-between; align-items: flex-start; }
        .logo { font-family: 'Orbitron', monospace; font-size: 1.4rem; font-weight: 700; color: #fff; text-transform: uppercase; letter-spacing: 0.3em; text-shadow: 0 0 30px rgba(255,255,255,0.5); }
        .logo span { opacity: 0.4; font-weight: 400; }
        .player-count { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); padding: 10px 20px; border-radius: 30px; font-size: 0.85rem; color: rgba(255,255,255,0.7); letter-spacing: 0.1em; backdrop-filter: blur(10px); }
        .player-count strong { color: #fff; font-weight: 500; }
        .controls-hint { bottom: 30px; left: 30px; color: rgba(255,255,255,0.3); font-size: 0.8rem; letter-spacing: 0.05em; }
        .controls-hint kbd { display: inline-block; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 4px; margin: 0 3px; font-family: 'Orbitron', monospace; font-size: 0.7rem; }
        .joystick-zone { position: fixed; bottom: 0; left: 0; width: 50%; height: 40%; z-index: 50; }
        .joystick-container { position: absolute; bottom: 80px; left: 60px; width: 120px; height: 120px; background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.15); border-radius: 50%; display: none; align-items: center; justify-content: center; }
        .joystick-knob { width: 50px; height: 50px; background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4), rgba(255,255,255,0.1)); border-radius: 50%; }
        .look-zone { position: fixed; bottom: 0; right: 0; width: 50%; height: 40%; z-index: 50; }
        .your-color { position: fixed; bottom: 30px; right: 30px; display: flex; align-items: center; gap: 12px; color: rgba(255,255,255,0.5); font-size: 0.8rem; letter-spacing: 0.05em; }
        .color-orb { width: 24px; height: 24px; border-radius: 50%; box-shadow: 0 0 20px currentColor, inset 0 0 10px rgba(255,255,255,0.3); }
        .loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; transition: opacity 0.8s ease, visibility 0.8s; }
        .loading-screen.hidden { opacity: 0; visibility: hidden; }
        .loading-text { font-family: 'Orbitron', monospace; font-size: 1rem; color: rgba(255,255,255,0.6); letter-spacing: 0.5em; margin-top: 30px; animation: pulse 1.5s ease-in-out infinite; }
        .loading-ring { width: 60px; height: 60px; border: 2px solid rgba(255,255,255,0.1); border-top-color: rgba(255,255,255,0.8); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
        @media (max-width: 768px) {
            .header { padding: 15px 20px; }
            .logo { font-size: 1rem; }
            .player-count { font-size: 0.75rem; padding: 8px 15px; }
            .controls-hint { display: none; }
            .joystick-container { display: flex; }
            .your-color { bottom: auto; top: 70px; right: 20px; }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loading">
        <div class="loading-ring"></div>
        <div class="loading-text">ENTERING VOID</div>
    </div>
    <div id="canvas-container"></div>
    <div class="ui-overlay header">
        <div class="logo">VOID<span>SPACE</span></div>
        <div class="player-count"><strong id="playerCount">0</strong> IN VOID</div>
    </div>
    <div class="ui-overlay controls-hint">
        <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> MOVE Â· <kbd>MOUSE</kbd> LOOK
    </div>
    <div class="your-color">YOUR ESSENCE <div class="color-orb" id="yourColor"></div></div>
    <div class="joystick-zone" id="joystickZone">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>
    <div class="look-zone" id="lookZone"></div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        firebase.initializeApp({
            apiKey: "AIzaSyDI9HGn4Dzd00Q_zLQZMRapI3Z8wX7ltHw",
            authDomain: "interact-mc.firebaseapp.com",
            databaseURL: "https://interact-mc-default-rtdb.firebaseio.com",
            projectId: "interact-mc",
            storageBucket: "interact-mc.firebasestorage.app",
            messagingSenderId: "336656676684",
            appId: "1:336656676684:web:8b348d7a2a9529b42ac1e9"
        });
        const database = firebase.database();

        const state = {
            playerId: 'player_' + Math.random().toString(36).substr(2, 9),
            playerColor: `hsl(${Math.random()*360}, ${70+Math.random()*30}%, ${50+Math.random()*20}%)`,
            position: { x: 0, y: 2, z: 0 },
            rotation: { x: 0, y: 0 },
            velocity: { x: 0, z: 0 },
            players: {},
            keys: { w: false, a: false, s: false, d: false, shift: false },
            isMobile: /Android|iPhone|iPad|iPod/i.test(navigator.userAgent),
            joystick: { active: false, x: 0, y: 0 }
        };

        let scene, camera, renderer, playerMeshes = {}, radiationStreams = [];

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Skybox - gradient dome from dark floor to bright heavenly ceiling
            const skyCanvas = document.createElement('canvas');
            skyCanvas.width = 1024;
            skyCanvas.height = 1024;
            const ctx = skyCanvas.getContext('2d');
            
            // Radial gradient from center (top of dome) outward
            const gradient = ctx.createRadialGradient(512, 512, 0, 512, 512, 512);
            gradient.addColorStop(0, '#fffaf5');
            gradient.addColorStop(0.15, '#fff0e0');
            gradient.addColorStop(0.3, '#e8d0b8');
            gradient.addColorStop(0.5, '#9080708a');
            gradient.addColorStop(0.7, '#3a3035');
            gradient.addColorStop(1, '#1a1018');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 1024);
            
            const skyTexture = new THREE.CanvasTexture(skyCanvas);
            const skyGeo = new THREE.SphereGeometry(400, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.6);
            const skyMat = new THREE.MeshBasicMaterial({ map: skyTexture, side: THREE.BackSide });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.rotation.x = Math.PI;
            sky.position.y = 5;
            scene.add(sky);

            // Lighting
            scene.add(new THREE.AmbientLight(0x6666aa, 1.2));
            scene.add(new THREE.HemisphereLight(0xfff8e0, 0x444466, 1.2));
            const sunLight = new THREE.DirectionalLight(0xfff5e6, 1);
            sunLight.position.set(0, 100, 0);
            scene.add(sunLight);

            createEnvironment();
            window.addEventListener('resize', () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            });
        }

        function createEnvironment() {
            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshStandardMaterial({ color: 0x2a2520, metalness: 0.2, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            scene.add(new THREE.GridHelper(200, 50, 0x8a8070, 0x3a3530));

            // Roman pillars
            const marbleMat = new THREE.MeshStandardMaterial({ color: 0xf5f0e6, emissive: 0x222218, emissiveIntensity: 0.1 });
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, emissive: 0x8b7320, emissiveIntensity: 0.3, metalness: 0.8 });
            
            [30, 55, 85].forEach((radius, tier) => {
                const count = 24 - tier * 6;
                const height = 60 + tier * 20;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + tier * 0.2;
                    const x = Math.cos(angle) * radius, z = Math.sin(angle) * radius;
                    const pillar = new THREE.Group();
                    
                    // Base
                    const base = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 2.5), marbleMat);
                    base.position.y = 0.75;
                    pillar.add(base);
                    
                    // Column
                    const col = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.88, height, 16), marbleMat);
                    col.position.y = 1.5 + height / 2;
                    pillar.add(col);
                    
                    // Capital
                    const cap = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 0.8, 1.5, 16), marbleMat);
                    cap.position.y = 1.5 + height + 0.75;
                    pillar.add(cap);
                    
                    // Gold ring
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 8, 24), goldMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = 1.5 + height + 0.5;
                    pillar.add(ring);
                    
                    pillar.position.set(x, 0, z);
                    scene.add(pillar);
                }
            });

            // Cosmic radiation streams
            for (let s = 0; s < 6; s++) {
                const positions = new Float32Array(200 * 3);
                const startAngle = (s / 6) * Math.PI * 2;
                const radius = 50 + Math.random() * 40;
                
                for (let i = 0; i < 200; i++) {
                    const t = i / 200;
                    const angle = startAngle + t * Math.PI * 0.5;
                    const r = radius + Math.sin(t * Math.PI * 4) * 12;
                    positions[i * 3] = Math.cos(angle) * r + (Math.random() - 0.5) * 8;
                    positions[i * 3 + 1] = 8 + t * 30 + (Math.random() - 0.5) * 5;
                    positions[i * 3 + 2] = Math.sin(angle) * r + (Math.random() - 0.5) * 8;
                }
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const stream = new THREE.Points(geo, new THREE.PointsMaterial({
                    color: s % 2 ? 0xffcc77 : 0xeebb88, size: 0.4, transparent: true, opacity: 0.7
                }));
                stream.userData = { speed: 0.0002 + Math.random() * 0.0002, dir: s % 2 ? 1 : -1 };
                scene.add(stream);
                radiationStreams.push(stream);
            }
        }

        function createPlayerMesh(color) {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.8 });

            // Head
            g.add(new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), mat));
            g.children[0].position.y = 1.6;
            
            // Torso
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.15, 0.6, 8), mat);
            torso.position.y = 1.1;
            g.add(torso);

            // Arms & Legs helper
            const limb = (px, py, rz, len) => {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, len, 6), mat);
                m.position.set(px, py, 0);
                m.rotation.z = rz;
                return m;
            };
            
            g.userData.leftArm = limb(-0.3, 1.1, 0.2, 0.5); g.add(g.userData.leftArm);
            g.userData.rightArm = limb(0.3, 1.1, -0.2, 0.5); g.add(g.userData.rightArm);
            g.userData.leftLeg = limb(-0.1, 0.5, 0, 0.6); g.add(g.userData.leftLeg);
            g.userData.rightLeg = limb(0.1, 0.5, 0, 0.6); g.add(g.userData.rightLeg);

            const light = new THREE.PointLight(color, 0.6, 8);
            light.position.y = 1.1;
            g.add(light);

            g.userData.lastPos = { x: 0, z: 0 };
            g.userData.phase = 0;
            return g;
        }

        function updatePlayerMesh(id, data) {
            if (id === state.playerId) return;
            if (!playerMeshes[id]) {
                playerMeshes[id] = createPlayerMesh(data.color);
                scene.add(playerMeshes[id]);
            }

            const m = playerMeshes[id];
            m.position.lerp(new THREE.Vector3(data.x, data.y - 1.8, data.z), 0.15);

            const dx = data.x - m.userData.lastPos.x, dz = data.z - m.userData.lastPos.z;
            if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
                m.rotation.y = Math.atan2(dx, dz);
                m.userData.phase += 0.2;
                const swing = Math.sin(m.userData.phase) * 0.4;
                m.userData.leftArm.rotation.x = swing;
                m.userData.rightArm.rotation.x = -swing;
                m.userData.leftLeg.rotation.x = -swing;
                m.userData.rightLeg.rotation.x = swing;
            } else {
                ['leftArm', 'rightArm', 'leftLeg', 'rightLeg'].forEach(l => m.userData[l].rotation.x *= 0.9);
            }
            m.userData.lastPos = { x: data.x, z: data.z };
        }

        function initFirebase() {
            const ref = database.ref('players/' + state.playerId);
            ref.set({ x: 0, y: 2, z: 0, color: state.playerColor, lastUpdate: firebase.database.ServerValue.TIMESTAMP });
            ref.onDisconnect().remove();

            database.ref('players').on('value', snap => {
                const players = snap.val() || {};
                document.getElementById('playerCount').textContent = Object.keys(players).length;
                Object.keys(playerMeshes).forEach(id => { if (!players[id]) { scene.remove(playerMeshes[id]); delete playerMeshes[id]; } });
                Object.entries(players).forEach(([id, data]) => updatePlayerMesh(id, data));
            });
        }

        function initControls() {
            const setKey = (e, val) => {
                const k = e.key.toLowerCase();
                if (k in state.keys) state.keys[k] = val;
                if (e.key === 'Shift') state.keys.shift = val;
            };
            document.addEventListener('keydown', e => setKey(e, true));
            document.addEventListener('keyup', e => setKey(e, false));

            if (!state.isMobile) {
                document.addEventListener('click', () => renderer.domElement.requestPointerLock());
                document.addEventListener('mousemove', e => {
                    if (document.pointerLockElement === renderer.domElement) {
                        state.rotation.y -= e.movementX * 0.002;
                        state.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, state.rotation.x - e.movementY * 0.002));
                    }
                });
            } else {
                const jZone = document.getElementById('joystickZone');
                const jCont = document.getElementById('joystickContainer');
                const jKnob = document.getElementById('joystickKnob');
                const lZone = document.getElementById('lookZone');
                let jOrigin = {x:0,y:0}, lOrigin = {x:0,y:0}, lTouchId = null;

                jZone.addEventListener('touchstart', e => {
                    e.preventDefault();
                    state.joystick.active = true;
                    jOrigin = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    jCont.style.left = (jOrigin.x - 60) + 'px';
                    jCont.style.bottom = (innerHeight - jOrigin.y - 60) + 'px';
                    jCont.style.display = 'flex';
                });
                jZone.addEventListener('touchmove', e => {
                    if (!state.joystick.active) return;
                    const dx = e.touches[0].clientX - jOrigin.x, dy = e.touches[0].clientY - jOrigin.y;
                    const dist = Math.min(Math.hypot(dx, dy), 50), ang = Math.atan2(dy, dx);
                    jKnob.style.transform = `translate(${Math.cos(ang)*dist}px, ${Math.sin(ang)*dist}px)`;
                    state.joystick.x = Math.cos(ang) * dist / 50;
                    state.joystick.y = Math.sin(ang) * dist / 50;
                });
                jZone.addEventListener('touchend', () => {
                    state.joystick = { active: false, x: 0, y: 0 };
                    jKnob.style.transform = 'translate(0,0)';
                    jCont.style.display = 'none';
                });

                lZone.addEventListener('touchstart', e => { lTouchId = e.changedTouches[0].identifier; lOrigin = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }; });
                lZone.addEventListener('touchmove', e => {
                    for (let t of e.changedTouches) {
                        if (t.identifier === lTouchId) {
                            state.rotation.y -= (t.clientX - lOrigin.x) * 0.005;
                            state.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, state.rotation.x - (t.clientY - lOrigin.y) * 0.005));
                            lOrigin = { x: t.clientX, y: t.clientY };
                        }
                    }
                });
                lZone.addEventListener('touchend', e => { for (let t of e.changedTouches) if (t.identifier === lTouchId) lTouchId = null; });
            }
        }

        let lastSync = 0;
        function gameLoop() {
            requestAnimationFrame(gameLoop);

            const speed = state.keys.shift ? 0.225 : 0.15;
            let mx = 0, mz = 0;
            if (state.isMobile && state.joystick.active) { mx = state.joystick.x; mz = state.joystick.y; }
            else { if (state.keys.w) mz--; if (state.keys.s) mz++; if (state.keys.a) mx--; if (state.keys.d) mx++; }
            
            const len = Math.hypot(mx, mz);
            if (len > 0) { mx /= len; mz /= len; }
            
            const sin = Math.sin(state.rotation.y), cos = Math.cos(state.rotation.y);
            state.velocity.x = (state.velocity.x + (mz * sin + mx * cos) * speed) * 0.85;
            state.velocity.z = (state.velocity.z + (mz * cos - mx * sin) * speed) * 0.85;
            state.position.x += state.velocity.x;
            state.position.z += state.velocity.z;

            camera.position.set(state.position.x, state.position.y, state.position.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = state.rotation.y;
            camera.rotation.x = state.rotation.x;

            radiationStreams.forEach(s => s.rotation.y += s.userData.speed * s.userData.dir);

            if (Date.now() - lastSync > 50) {
                database.ref('players/' + state.playerId).update({ x: state.position.x, y: state.position.y, z: state.position.z, lastUpdate: firebase.database.ServerValue.TIMESTAMP });
                lastSync = Date.now();
            }

            renderer.render(scene, camera);
        }

        function init() {
            document.getElementById('yourColor').style.backgroundColor = state.playerColor;
            document.getElementById('yourColor').style.color = state.playerColor;
            initThree();
            initControls();
            initFirebase();
            setTimeout(() => document.getElementById('loading').classList.add('hidden'), 1500);
            gameLoop();
        }

        document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', init) : init();
    </script>
</body>
</html>