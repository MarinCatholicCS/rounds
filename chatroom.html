<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Void Space</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; touch-action: none; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        canvas { display: block; }
        .ui-overlay { position: fixed; z-index: 100; pointer-events: none; }
        .ui-overlay * { pointer-events: auto; }
        .header { top: 0; left: 0; right: 0; padding: 20px 30px; display: flex; justify-content: space-between; align-items: flex-start; }
        .logo { font-family: 'Orbitron', monospace; font-size: 1.4rem; font-weight: 700; color: #fff; text-transform: uppercase; letter-spacing: 0.3em; text-shadow: 0 0 30px rgba(255,255,255,0.5); }
        .logo span { opacity: 0.4; font-weight: 400; }
        .player-count { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); padding: 10px 20px; border-radius: 30px; font-size: 0.85rem; color: rgba(255,255,255,0.7); letter-spacing: 0.1em; backdrop-filter: blur(10px); }
        .player-count strong { color: #fff; font-weight: 500; }
        .controls-hint { bottom: 30px; left: 30px; color: rgba(255,255,255,0.3); font-size: 0.8rem; letter-spacing: 0.05em; }
        .controls-hint kbd { display: inline-block; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 4px; margin: 0 3px; font-family: 'Orbitron', monospace; font-size: 0.7rem; }
        .joystick-zone { position: fixed; bottom: 0; left: 0; width: 50%; height: 40%; z-index: 50; }
        .joystick-container { position: absolute; bottom: 80px; left: 60px; width: 120px; height: 120px; background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.15); border-radius: 50%; display: none; align-items: center; justify-content: center; }
        .joystick-knob { width: 50px; height: 50px; background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4), rgba(255,255,255,0.1)); border-radius: 50%; }
        .look-zone { position: fixed; bottom: 0; right: 0; width: 50%; height: 40%; z-index: 50; }
        .your-color { position: fixed; bottom: 30px; right: 30px; display: flex; align-items: center; gap: 12px; color: rgba(255,255,255,0.5); font-size: 0.8rem; letter-spacing: 0.05em; }
        .color-orb { width: 24px; height: 24px; border-radius: 50%; box-shadow: 0 0 20px currentColor, inset 0 0 10px rgba(255,255,255,0.3); }
        .loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; transition: opacity 0.8s ease, visibility 0.8s; }
        .loading-screen.hidden { opacity: 0; visibility: hidden; }
        .loading-text { font-family: 'Orbitron', monospace; font-size: 1rem; color: rgba(255,255,255,0.6); letter-spacing: 0.5em; margin-top: 30px; animation: pulse 1.5s ease-in-out infinite; }
        .loading-ring { width: 60px; height: 60px; border: 2px solid rgba(255,255,255,0.1); border-top-color: rgba(255,255,255,0.8); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
        @media (max-width: 768px) {
            .header { padding: 15px 20px; }
            .logo { font-size: 1rem; }
            .player-count { font-size: 0.75rem; padding: 8px 15px; }
            .controls-hint { display: none; }
            .joystick-container { display: flex; }
            .your-color { bottom: auto; top: 70px; right: 20px; }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loading">
        <div class="loading-ring"></div>
        <div class="loading-text">ENTERING VOID</div>
    </div>
    <div id="canvas-container"></div>
    <div class="ui-overlay header">
        <div class="logo">VOID<span>SPACE</span></div>
        <div class="player-count"><strong id="playerCount">0</strong> IN VOID</div>
    </div>
    <div class="ui-overlay controls-hint">
        <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> MOVE Â· <kbd>MOUSE</kbd> LOOK
    </div>
    <div class="your-color">YOUR ESSENCE <div class="color-orb" id="yourColor"></div></div>
    <div class="joystick-zone" id="joystickZone">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>
    <div class="look-zone" id="lookZone"></div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        firebase.initializeApp({
            apiKey: "AIzaSyDI9HGn4Dzd00Q_zLQZMRapI3Z8wX7ltHw",
            authDomain: "interact-mc.firebaseapp.com",
            databaseURL: "https://interact-mc-default-rtdb.firebaseio.com",
            projectId: "interact-mc",
            storageBucket: "interact-mc.firebasestorage.app",
            messagingSenderId: "336656676684",
            appId: "1:336656676684:web:8b348d7a2a9529b42ac1e9"
        });
        const database = firebase.database();

        const state = {
            playerId: 'player_' + Math.random().toString(36).substr(2, 9),
            playerColor: `hsl(${Math.random()*360}, ${70+Math.random()*30}%, ${50+Math.random()*20}%)`,
            position: { x: 0, y: 2, z: 0 },
            rotation: { x: 0, y: 0 },
            velocity: { x: 0, z: 0 },
            players: {},
            keys: { w: false, a: false, s: false, d: false, shift: false },
            isMobile: /Android|iPhone|iPad|iPod/i.test(navigator.userAgent),
            joystick: { active: false, x: 0, y: 0 }
        };

        let scene, camera, renderer, playerMeshes = {}, radiationStreams = [];

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Skybox - gradient dome from dark floor to bright heavenly ceiling
            const skyCanvas = document.createElement('canvas');
            skyCanvas.width = 1024;
            skyCanvas.height = 1024;
            const ctx = skyCanvas.getContext('2d');
            
            // Radial gradient from center (top of dome) outward
            const gradient = ctx.createRadialGradient(512, 512, 0, 512, 512, 512);
            gradient.addColorStop(0, '#fffaf5');
            gradient.addColorStop(0.15, '#fff0e0');
            gradient.addColorStop(0.3, '#e8d0b8');
            gradient.addColorStop(0.5, '#9080708a');
            gradient.addColorStop(0.7, '#3a3035');
            gradient.addColorStop(1, '#1a1018');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 1024);
            
            const skyTexture = new THREE.CanvasTexture(skyCanvas);
            const skyGeo = new THREE.SphereGeometry(400, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.6);
            const skyMat = new THREE.MeshBasicMaterial({ map: skyTexture, side: THREE.BackSide });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.rotation.x = Math.PI;
            sky.position.y = 5;
            scene.add(sky);

            // Lighting
            scene.add(new THREE.AmbientLight(0x6666aa, 1.2));
            scene.add(new THREE.HemisphereLight(0xfff8e0, 0x444466, 1.2));
            const sunLight = new THREE.DirectionalLight(0xfff5e6, 1);
            sunLight.position.set(0, 100, 0);
            scene.add(sunLight);

            createEnvironment();
            window.addEventListener('resize', () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            });
        }

        function createEnvironment() {
            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshStandardMaterial({ color: 0x2a2520, metalness: 0.2, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            scene.add(new THREE.GridHelper(200, 50, 0x8a8070, 0x3a3530));

            // Roman pillars
            const marbleMat = new THREE.MeshStandardMaterial({ color: 0xf5f0e6, emissive: 0x222218, emissiveIntensity: 0.1 });
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, emissive: 0x8b7320, emissiveIntensity: 0.3, metalness: 0.8 });
            
            [30, 55, 85].forEach((radius, tier) => {
                const count = 24 - tier * 6;
                const height = 60 + tier * 20;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + tier * 0.2;
                    const x = Math.cos(angle) * radius, z = Math.sin(angle) * radius;
                    const pillar = new THREE.Group();
                    
                    // Base
                    const base = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 2.5), marbleMat);
                    base.position.y = 0.75;
                    pillar.add(base);
                    
                    // Column
                    const col = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.88, height, 16), marbleMat);
                    col.position.y = 1.5 + height / 2;
                    pillar.add(col);
                    
                    // Capital
                    const cap = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 0.8, 1.5, 16), marbleMat);
                    cap.position.y = 1.5 + height + 0.75;
                    pillar.add(cap);
                    
                    // Gold ring
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 8, 24), goldMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = 1.5 + height + 0.5;
                    pillar.add(ring);
                    
                    pillar.position.set(x, 0, z);
                    scene.add(pillar);
                }
            });

            // Cosmic radiation streams
            for (let s = 0; s < 6; s++) {
                const positions = new Float32Array(200 * 3);
                const startAngle = (s / 6) * Math.PI * 2;
                const radius = 50 + Math.random() * 40;
                
                for (let i = 0; i < 200; i++) {
                    const t = i / 200;
                    const angle = startAngle + t * Math.PI * 0.5;
                    const r = radius + Math.sin(t * Math.PI * 4) * 12;
                    positions[i * 3] = Math.cos(angle) * r + (Math.random() - 0.5) * 8;
                    positions[i * 3 + 1] = 8 + t * 30 + (Math.random() - 0.5) * 5;
                    positions[i * 3 + 2] = Math.sin(angle) * r + (Math.random() - 0.5) * 8;
                }
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const stream = new THREE.Points(geo, new THREE.PointsMaterial({
                    color: s % 2 ? 0xffcc77 : 0xeebb88, size: 0.4, transparent: true, opacity: 0.7
                }));
                stream.userData = { speed: 0.0002 + Math.random() * 0.0002, dir: s % 2 ? 1 : -1 };
                scene.add(stream);
                radiationStreams.push(stream);
            }
        }

        function createPlayerMesh(color) {
            const g = new THREE.Group();
            
            // Core neon material
            const mat = new THREE.MeshStandardMaterial({ 
                color, 
                emissive: color, 
                emissiveIntensity: 0.6,
                metalness: 0.2,
                roughness: 0.3
            });
            
            // Outer glow material
            const glowMat = new THREE.MeshBasicMaterial({ 
                color, 
                transparent: true, 
                opacity: 0.15,
                side: THREE.BackSide
            });

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.18, 16, 16), mat);
            head.position.y = 1.5;
            g.add(head);
            
            // Head glow
            const headGlow = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), glowMat);
            headGlow.position.y = 1.5;
            g.add(headGlow);
            
            // Neck
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 0.12, 8), mat);
            neck.position.y = 1.28;
            g.add(neck);
            
            // Torso - more refined shape
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.1, 0.45, 10), mat);
            torso.position.y = 1.0;
            g.add(torso);
            
            // Torso glow
            const torsoGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.18, 0.5, 10), glowMat);
            torsoGlow.position.y = 1.0;
            g.add(torsoGlow);
            
            // Hips
            const hips = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.15, 8), mat);
            hips.position.y = 0.7;
            g.add(hips);

            // Shoulder joints
            const lShoulder = new THREE.Mesh(new THREE.SphereGeometry(0.055, 8, 8), mat);
            lShoulder.position.set(-0.18, 1.18, 0);
            g.add(lShoulder);
            const rShoulder = new THREE.Mesh(new THREE.SphereGeometry(0.055, 8, 8), mat);
            rShoulder.position.set(0.18, 1.18, 0);
            g.add(rShoulder);

            // Upper arms
            const armGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.25, 8);
            const lUpperArm = new THREE.Mesh(armGeo, mat);
            lUpperArm.position.set(-0.2, 1.02, 0);
            g.add(lUpperArm);
            const rUpperArm = new THREE.Mesh(armGeo, mat);
            rUpperArm.position.set(0.2, 1.02, 0);
            g.add(rUpperArm);
            
            // Elbow joints
            const lElbow = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), mat);
            lElbow.position.set(-0.2, 0.88, 0);
            g.add(lElbow);
            const rElbow = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), mat);
            rElbow.position.set(0.2, 0.88, 0);
            g.add(rElbow);
            
            // Forearms
            const forearmGeo = new THREE.CylinderGeometry(0.035, 0.03, 0.22, 8);
            const lForearm = new THREE.Mesh(forearmGeo, mat);
            lForearm.position.set(-0.2, 0.75, 0);
            g.add(lForearm);
            const rForearm = new THREE.Mesh(forearmGeo, mat);
            rForearm.position.set(0.2, 0.75, 0);
            g.add(rForearm);
            
            // Hands
            const lHand = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), mat);
            lHand.position.set(-0.2, 0.62, 0);
            g.add(lHand);
            const rHand = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), mat);
            rHand.position.set(0.2, 0.62, 0);
            g.add(rHand);

            // Upper legs
            const legGeo = new THREE.CylinderGeometry(0.05, 0.04, 0.3, 8);
            const lUpperLeg = new THREE.Mesh(legGeo, mat);
            lUpperLeg.position.set(-0.07, 0.5, 0);
            g.add(lUpperLeg);
            const rUpperLeg = new THREE.Mesh(legGeo, mat);
            rUpperLeg.position.set(0.07, 0.5, 0);
            g.add(rUpperLeg);
            
            // Knee joints
            const lKnee = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 8), mat);
            lKnee.position.set(-0.07, 0.33, 0);
            g.add(lKnee);
            const rKnee = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 8), mat);
            rKnee.position.set(0.07, 0.33, 0);
            g.add(rKnee);
            
            // Lower legs
            const calfGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.28, 8);
            const lCalf = new THREE.Mesh(calfGeo, mat);
            lCalf.position.set(-0.07, 0.17, 0);
            g.add(lCalf);
            const rCalf = new THREE.Mesh(calfGeo, mat);
            rCalf.position.set(0.07, 0.17, 0);
            g.add(rCalf);
            
            // Feet
            const footGeo = new THREE.BoxGeometry(0.06, 0.04, 0.1);
            const lFoot = new THREE.Mesh(footGeo, mat);
            lFoot.position.set(-0.07, 0.02, 0.02);
            g.add(lFoot);
            const rFoot = new THREE.Mesh(footGeo, mat);
            rFoot.position.set(0.07, 0.02, 0.02);
            g.add(rFoot);

            // Neon point light
            const light = new THREE.PointLight(color, 1.0, 6);
            light.position.y = 1.0;
            g.add(light);
            
            // Outer aura glow (large soft sphere)
            const auraMat = new THREE.MeshBasicMaterial({ 
                color, 
                transparent: true, 
                opacity: 0.05,
                side: THREE.BackSide
            });
            const aura = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), auraMat);
            aura.position.y = 0.9;
            g.add(aura);

            // Store refs for animation
            g.userData = {
                head, neck, torso, hips,
                lUpperArm, rUpperArm, lForearm, rForearm, lHand, rHand,
                lElbow, rElbow, lShoulder, rShoulder,
                lUpperLeg, rUpperLeg, lCalf, rCalf, lKnee, rKnee, lFoot, rFoot,
                headGlow, torsoGlow, aura,
                lastPos: { x: 0, z: 0 },
                walkPhase: Math.random() * Math.PI * 2
            };
            
            return g;
        }

        function updatePlayerMesh(id, data) {
            if (id === state.playerId) return;
            if (!playerMeshes[id]) {
                playerMeshes[id] = createPlayerMesh(data.color);
                scene.add(playerMeshes[id]);
            }

            const m = playerMeshes[id];
            const u = m.userData;
            m.position.lerp(new THREE.Vector3(data.x, data.y - 1.8, data.z), 0.1);

            const dx = data.x - u.lastPos.x, dz = data.z - u.lastPos.z;
            const speed = Math.hypot(dx, dz);
            const isMoving = speed > 0.005;
            const time = performance.now() * 0.001;
            
            if (isMoving) {
                // Smooth rotation toward movement direction
                const targetRot = Math.atan2(dx, dz);
                const diff = Math.atan2(Math.sin(targetRot - m.rotation.y), Math.cos(targetRot - m.rotation.y));
                m.rotation.y += diff * 0.12;
                
                // Walk cycle
                u.walkPhase += Math.min(speed * 12, 0.25);
                const phase = u.walkPhase;
                const armSwing = Math.sin(phase) * 0.6;
                const legSwing = Math.sin(phase) * 0.5;
                const bounce = Math.abs(Math.sin(phase)) * 0.03;
                
                // Upper body bob
                u.head.position.y = 1.5 + bounce;
                u.headGlow.position.y = 1.5 + bounce;
                u.torso.position.y = 1.0 + bounce * 0.7;
                u.torsoGlow.position.y = 1.0 + bounce * 0.7;
                u.neck.position.y = 1.28 + bounce * 0.8;
                
                // Shoulders follow torso
                u.lShoulder.position.y = 1.18 + bounce * 0.7;
                u.rShoulder.position.y = 1.18 + bounce * 0.7;
                
                // Arm swing (opposite to legs)
                u.lUpperArm.rotation.x = armSwing;
                u.rUpperArm.rotation.x = -armSwing;
                u.lUpperArm.position.y = 1.02 + bounce * 0.5;
                u.rUpperArm.position.y = 1.02 + bounce * 0.5;
                
                u.lElbow.position.set(-0.2, 0.88 + bounce * 0.3 + Math.sin(phase) * 0.03, Math.sin(phase) * 0.05);
                u.rElbow.position.set(0.2, 0.88 + bounce * 0.3 - Math.sin(phase) * 0.03, -Math.sin(phase) * 0.05);
                
                u.lForearm.rotation.x = armSwing * 0.5 - 0.2;
                u.rForearm.rotation.x = -armSwing * 0.5 - 0.2;
                u.lForearm.position.set(-0.2, 0.75 + bounce * 0.2, Math.sin(phase) * 0.08);
                u.rForearm.position.set(0.2, 0.75 + bounce * 0.2, -Math.sin(phase) * 0.08);
                
                u.lHand.position.set(-0.2, 0.62 + bounce * 0.1, Math.sin(phase) * 0.1);
                u.rHand.position.set(0.2, 0.62 + bounce * 0.1, -Math.sin(phase) * 0.1);
                
                // Leg swing
                u.lUpperLeg.rotation.x = -legSwing;
                u.rUpperLeg.rotation.x = legSwing;
                
                u.lKnee.position.set(-0.07, 0.33, -Math.sin(phase) * 0.08);
                u.rKnee.position.set(0.07, 0.33, Math.sin(phase) * 0.08);
                
                u.lCalf.rotation.x = Math.max(0, -legSwing * 0.8);
                u.rCalf.rotation.x = Math.max(0, legSwing * 0.8);
                u.lCalf.position.set(-0.07, 0.17, -Math.sin(phase) * 0.06);
                u.rCalf.position.set(0.07, 0.17, Math.sin(phase) * 0.06);
                
                u.lFoot.position.set(-0.07, 0.02, 0.02 - Math.sin(phase) * 0.04);
                u.rFoot.position.set(0.07, 0.02, 0.02 + Math.sin(phase) * 0.04);
                
                // Subtle torso twist
                u.torso.rotation.y = Math.sin(phase) * 0.08;
                u.hips.rotation.y = -Math.sin(phase) * 0.05;
                
                // Aura pulses slightly when moving
                u.aura.scale.setScalar(1 + Math.sin(phase * 2) * 0.05);
                
            } else {
                // Idle animation - breathing and subtle sway
                const breathe = Math.sin(time * 1.2 + id.charCodeAt(7)) * 0.015;
                const sway = Math.sin(time * 0.6 + id.charCodeAt(8)) * 0.02;
                
                // Gentle body movement
                u.head.position.y = 1.5 + breathe;
                u.headGlow.position.y = 1.5 + breathe;
                u.torso.position.y = 1.0 + breathe * 0.6;
                u.torsoGlow.position.y = 1.0 + breathe * 0.6;
                u.neck.position.y = 1.28 + breathe * 0.8;
                
                // Subtle sway
                u.torso.rotation.z = sway;
                u.torso.rotation.y *= 0.95;
                u.hips.rotation.y *= 0.95;
                
                // Arms relax
                u.lUpperArm.rotation.x += (0 - u.lUpperArm.rotation.x) * 0.08;
                u.rUpperArm.rotation.x += (0 - u.rUpperArm.rotation.x) * 0.08;
                u.lForearm.rotation.x += (-0.15 - u.lForearm.rotation.x) * 0.08;
                u.rForearm.rotation.x += (-0.15 - u.rForearm.rotation.x) * 0.08;
                
                // Reset positions smoothly
                u.lElbow.position.lerp(new THREE.Vector3(-0.2, 0.88, 0), 0.08);
                u.rElbow.position.lerp(new THREE.Vector3(0.2, 0.88, 0), 0.08);
                u.lForearm.position.lerp(new THREE.Vector3(-0.2, 0.75, 0), 0.08);
                u.rForearm.position.lerp(new THREE.Vector3(0.2, 0.75, 0), 0.08);
                u.lHand.position.lerp(new THREE.Vector3(-0.2, 0.62, 0), 0.08);
                u.rHand.position.lerp(new THREE.Vector3(0.2, 0.62, 0), 0.08);
                
                // Legs return to neutral
                u.lUpperLeg.rotation.x *= 0.92;
                u.rUpperLeg.rotation.x *= 0.92;
                u.lCalf.rotation.x *= 0.92;
                u.rCalf.rotation.x *= 0.92;
                u.lKnee.position.lerp(new THREE.Vector3(-0.07, 0.33, 0), 0.08);
                u.rKnee.position.lerp(new THREE.Vector3(0.07, 0.33, 0), 0.08);
                u.lCalf.position.lerp(new THREE.Vector3(-0.07, 0.17, 0), 0.08);
                u.rCalf.position.lerp(new THREE.Vector3(0.07, 0.17, 0), 0.08);
                u.lFoot.position.lerp(new THREE.Vector3(-0.07, 0.02, 0.02), 0.08);
                u.rFoot.position.lerp(new THREE.Vector3(0.07, 0.02, 0.02), 0.08);
                
                // Aura gentle pulse
                u.aura.scale.setScalar(1 + Math.sin(time * 1.5) * 0.03);
            }
            
            u.lastPos = { x: data.x, z: data.z };
        }

        function initFirebase() {
            const ref = database.ref('players/' + state.playerId);
            ref.set({ x: 0, y: 2, z: 0, color: state.playerColor, lastUpdate: firebase.database.ServerValue.TIMESTAMP });
            ref.onDisconnect().remove();

            database.ref('players').on('value', snap => {
                const players = snap.val() || {};
                document.getElementById('playerCount').textContent = Object.keys(players).length;
                Object.keys(playerMeshes).forEach(id => { if (!players[id]) { scene.remove(playerMeshes[id]); delete playerMeshes[id]; } });
                Object.entries(players).forEach(([id, data]) => updatePlayerMesh(id, data));
            });
        }

        function initControls() {
            const setKey = (e, val) => {
                const k = e.key.toLowerCase();
                if (k in state.keys) state.keys[k] = val;
                if (e.key === 'Shift') state.keys.shift = val;
            };
            document.addEventListener('keydown', e => setKey(e, true));
            document.addEventListener('keyup', e => setKey(e, false));

            if (!state.isMobile) {
                document.addEventListener('click', () => renderer.domElement.requestPointerLock());
                document.addEventListener('mousemove', e => {
                    if (document.pointerLockElement === renderer.domElement) {
                        state.rotation.y -= e.movementX * 0.002;
                        state.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, state.rotation.x - e.movementY * 0.002));
                    }
                });
            } else {
                const jZone = document.getElementById('joystickZone');
                const jCont = document.getElementById('joystickContainer');
                const jKnob = document.getElementById('joystickKnob');
                const lZone = document.getElementById('lookZone');
                let jOrigin = {x:0,y:0}, lOrigin = {x:0,y:0}, lTouchId = null;

                jZone.addEventListener('touchstart', e => {
                    e.preventDefault();
                    state.joystick.active = true;
                    jOrigin = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    jCont.style.left = (jOrigin.x - 60) + 'px';
                    jCont.style.bottom = (innerHeight - jOrigin.y - 60) + 'px';
                    jCont.style.display = 'flex';
                });
                jZone.addEventListener('touchmove', e => {
                    if (!state.joystick.active) return;
                    const dx = e.touches[0].clientX - jOrigin.x, dy = e.touches[0].clientY - jOrigin.y;
                    const dist = Math.min(Math.hypot(dx, dy), 50), ang = Math.atan2(dy, dx);
                    jKnob.style.transform = `translate(${Math.cos(ang)*dist}px, ${Math.sin(ang)*dist}px)`;
                    state.joystick.x = Math.cos(ang) * dist / 50;
                    state.joystick.y = Math.sin(ang) * dist / 50;
                });
                jZone.addEventListener('touchend', () => {
                    state.joystick = { active: false, x: 0, y: 0 };
                    jKnob.style.transform = 'translate(0,0)';
                    jCont.style.display = 'none';
                });

                lZone.addEventListener('touchstart', e => { lTouchId = e.changedTouches[0].identifier; lOrigin = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }; });
                lZone.addEventListener('touchmove', e => {
                    for (let t of e.changedTouches) {
                        if (t.identifier === lTouchId) {
                            state.rotation.y -= (t.clientX - lOrigin.x) * 0.005;
                            state.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, state.rotation.x - (t.clientY - lOrigin.y) * 0.005));
                            lOrigin = { x: t.clientX, y: t.clientY };
                        }
                    }
                });
                lZone.addEventListener('touchend', e => { for (let t of e.changedTouches) if (t.identifier === lTouchId) lTouchId = null; });
            }
        }

        let lastSync = 0;
        function gameLoop() {
            requestAnimationFrame(gameLoop);

            const speed = state.keys.shift ? 0.08 : 0.05;
            let mx = 0, mz = 0;
            if (state.isMobile && state.joystick.active) { mx = state.joystick.x; mz = state.joystick.y; }
            else { if (state.keys.w) mz--; if (state.keys.s) mz++; if (state.keys.a) mx--; if (state.keys.d) mx++; }
            
            const len = Math.hypot(mx, mz);
            if (len > 0) { mx /= len; mz /= len; }
            
            const sin = Math.sin(state.rotation.y), cos = Math.cos(state.rotation.y);
            state.velocity.x = (state.velocity.x + (mz * sin + mx * cos) * speed) * 0.88;
            state.velocity.z = (state.velocity.z + (mz * cos - mx * sin) * speed) * 0.88;
            state.position.x += state.velocity.x;
            state.position.z += state.velocity.z;

            camera.position.set(state.position.x, state.position.y, state.position.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = state.rotation.y;
            camera.rotation.x = state.rotation.x;

            radiationStreams.forEach(s => s.rotation.y += s.userData.speed * s.userData.dir);

            if (Date.now() - lastSync > 50) {
                database.ref('players/' + state.playerId).update({ x: state.position.x, y: state.position.y, z: state.position.z, lastUpdate: firebase.database.ServerValue.TIMESTAMP });
                lastSync = Date.now();
            }

            renderer.render(scene, camera);
        }

        function init() {
            document.getElementById('yourColor').style.backgroundColor = state.playerColor;
            document.getElementById('yourColor').style.color = state.playerColor;
            initThree();
            initControls();
            initFirebase();
            setTimeout(() => document.getElementById('loading').classList.add('hidden'), 1500);
            gameLoop();
        }

        document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', init) : init();
    </script>
</body>
</html>