<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Void Space</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        background: #000;
        font-family: "Rajdhani", sans-serif;
        touch-action: none;
      }
      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      canvas {
        display: block;
      }
      .ui-overlay {
        position: fixed;
        z-index: 100;
        pointer-events: none;
      }
      .ui-overlay * {
        pointer-events: auto;
      }
      .header {
        top: 0;
        left: 0;
        right: 0;
        padding: 20px 30px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
      }
      .logo {
        font-family: "Orbitron", monospace;
        font-size: 1.4rem;
        font-weight: 700;
        color: #fff;
        text-transform: uppercase;
        letter-spacing: 0.3em;
        text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
      }
      .logo span {
        opacity: 0.4;
        font-weight: 400;
      }
      .player-count {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 10px 20px;
        border-radius: 30px;
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.7);
        letter-spacing: 0.1em;
        backdrop-filter: blur(10px);
      }
      .player-count strong {
        color: #fff;
        font-weight: 500;
      }
      .controls-hint {
        bottom: 30px;
        left: 30px;
        color: rgba(255, 255, 255, 0.3);
        font-size: 0.8rem;
        letter-spacing: 0.05em;
      }
      .controls-hint kbd {
        display: inline-block;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 4px 10px;
        border-radius: 4px;
        margin: 0 3px;
        font-family: "Orbitron", monospace;
        font-size: 0.7rem;
      }
      .joystick-zone {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 50%;
        height: 40%;
        z-index: 50;
      }
      .joystick-container {
        position: absolute;
        bottom: 80px;
        left: 60px;
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid rgba(255, 255, 255, 0.15);
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
      }
      .joystick-knob {
        width: 50px;
        height: 50px;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(255, 255, 255, 0.4),
          rgba(255, 255, 255, 0.1)
        );
        border-radius: 50%;
      }
      .look-zone {
        position: fixed;
        bottom: 0;
        right: 0;
        width: 50%;
        height: 40%;
        z-index: 50;
      }
      .your-color {
        position: fixed;
        bottom: 30px;
        right: 30px;
        display: flex;
        align-items: center;
        gap: 12px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.8rem;
        letter-spacing: 0.05em;
      }
      .color-orb {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        box-shadow:
          0 0 20px currentColor,
          inset 0 0 10px rgba(255, 255, 255, 0.3);
      }
      .loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition:
          opacity 0.8s ease,
          visibility 0.8s;
      }
      .loading-screen.hidden {
        opacity: 0;
        visibility: hidden;
      }
      .loading-text {
        font-family: "Orbitron", monospace;
        font-size: 1rem;
        color: rgba(255, 255, 255, 0.6);
        letter-spacing: 0.5em;
        margin-top: 30px;
        animation: pulse 1.5s ease-in-out infinite;
      }
      .loading-ring {
        width: 60px;
        height: 60px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-top-color: rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }
      @media (max-width: 768px) {
        .header {
          padding: 15px 20px;
        }
        .logo {
          font-size: 1rem;
        }
        .player-count {
          font-size: 0.75rem;
          padding: 8px 15px;
        }
        .controls-hint {
          display: none;
        }
        .joystick-container {
          display: flex;
        }
        .your-color {
          bottom: auto;
          top: 70px;
          right: 20px;
        }
      }
    </style>
  </head>
  <body>
    <div class="loading-screen" id="loading">
      <div class="loading-ring"></div>
      <div class="loading-text">ENTERING VOID</div>
    </div>
    <div id="canvas-container"></div>
    <div class="ui-overlay header">
      <div class="logo">VOID<span>SPACE</span></div>
      <div class="player-count">
        <strong id="playerCount">0</strong> IN VOID
      </div>
    </div>
    <div class="ui-overlay controls-hint">
      <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> MOVE Â·
      <kbd>MOUSE</kbd> LOOK
    </div>
    <div class="your-color">
      YOUR ESSENCE
      <div class="color-orb" id="yourColor"></div>
    </div>
    <div class="joystick-zone" id="joystickZone">
      <div class="joystick-container" id="joystickContainer">
        <div class="joystick-knob" id="joystickKnob"></div>
      </div>
    </div>
    <div class="look-zone" id="lookZone"></div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      firebase.initializeApp({
        apiKey: "AIzaSyDI9HGn4Dzd00Q_zLQZMRapI3Z8wX7ltHw",
        authDomain: "interact-mc.firebaseapp.com",
        databaseURL: "https://interact-mc-default-rtdb.firebaseio.com",
        projectId: "interact-mc",
        storageBucket: "interact-mc.firebasestorage.app",
        messagingSenderId: "336656676684",
        appId: "1:336656676684:web:8b348d7a2a9529b42ac1e9",
      });
      const database = firebase.database();

      const state = {
        playerId: "player_" + Math.random().toString(36).substr(2, 9),
        playerColor: `hsl(${Math.random() * 360}, ${70 + Math.random() * 30}%, ${50 + Math.random() * 20}%)`,
        position: { x: 0, y: 2, z: 0 },
        rotation: { x: 0, y: 0 },
        velocity: { x: 0, z: 0 },
        players: {},
        keys: { w: false, a: false, s: false, d: false, shift: false },
        isMobile: /Android|iPhone|iPad|iPod/i.test(navigator.userAgent),
        joystick: { active: false, x: 0, y: 0 },
      };

      let scene,
        camera,
        renderer,
        playerMeshes = {},
        radiationStreams = [];

      function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          innerWidth / innerHeight,
          0.1,
          1000,
        );
        camera.position.set(0, 2, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document
          .getElementById("canvas-container")
          .appendChild(renderer.domElement);

        // Skybox - gradient dome from dark floor to bright heavenly ceiling
        const skyCanvas = document.createElement("canvas");
        skyCanvas.width = 1024;
        skyCanvas.height = 1024;
        const ctx = skyCanvas.getContext("2d");

        // Radial gradient from center (top of dome) outward
        const gradient = ctx.createRadialGradient(512, 512, 0, 512, 512, 512);
        gradient.addColorStop(0, "#fffaf5");
        gradient.addColorStop(0.15, "#fff0e0");
        gradient.addColorStop(0.3, "#e8d0b8");
        gradient.addColorStop(0.5, "#9080708a");
        gradient.addColorStop(0.7, "#3a3035");
        gradient.addColorStop(1, "#1a1018");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1024, 1024);

        const skyTexture = new THREE.CanvasTexture(skyCanvas);
        const skyGeo = new THREE.SphereGeometry(
          400,
          64,
          64,
          0,
          Math.PI * 2,
          0,
          Math.PI * 0.6,
        );
        const skyMat = new THREE.MeshBasicMaterial({
          map: skyTexture,
          side: THREE.BackSide,
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        sky.rotation.x = Math.PI;
        sky.position.y = 5;
        scene.add(sky);

        // Lighting
        scene.add(new THREE.AmbientLight(0x6666aa, 0.6));
        scene.add(new THREE.HemisphereLight(0xfff8e0, 0x444466, 0.8));

        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(30, 80, 30);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        sunLight.shadow.bias = -0.0001;
        scene.add(sunLight);

        createEnvironment();
        window.addEventListener("resize", () => {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
        });
      }

      function createEnvironment() {
        // Create gravel/dirt ground texture procedurally
        const groundCanvas = document.createElement("canvas");
        groundCanvas.width = 512;
        groundCanvas.height = 512;
        const gctx = groundCanvas.getContext("2d");

        // Base dirt color
        gctx.fillStyle = "#3d3530";
        gctx.fillRect(0, 0, 512, 512);

        // Add gravel texture with varied stones
        for (let i = 0; i < 3000; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = 1 + Math.random() * 4;
          const shade = Math.floor(40 + Math.random() * 30);
          gctx.fillStyle = `rgb(${shade + 10}, ${shade + 5}, ${shade})`;
          gctx.beginPath();
          gctx.ellipse(
            x,
            y,
            size,
            size * 0.7,
            Math.random() * Math.PI,
            0,
            Math.PI * 2,
          );
          gctx.fill();
        }

        // Add some darker patches
        for (let i = 0; i < 50; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = 10 + Math.random() * 30;
          gctx.fillStyle = "rgba(20, 18, 15, 0.3)";
          gctx.beginPath();
          gctx.ellipse(
            x,
            y,
            size,
            size * 0.8,
            Math.random() * Math.PI,
            0,
            Math.PI * 2,
          );
          gctx.fill();
        }

        // Add lighter dust/sand spots
        for (let i = 0; i < 800; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = 0.5 + Math.random() * 2;
          gctx.fillStyle = `rgba(${100 + Math.random() * 40}, ${90 + Math.random() * 30}, ${70 + Math.random() * 20}, 0.6)`;
          gctx.beginPath();
          gctx.arc(x, y, size, 0, Math.PI * 2);
          gctx.fill();
        }

        const groundTexture = new THREE.CanvasTexture(groundCanvas);
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(20, 20);

        // Create bump map for ground
        const bumpCanvas = document.createElement("canvas");
        bumpCanvas.width = 256;
        bumpCanvas.height = 256;
        const bctx = bumpCanvas.getContext("2d");
        bctx.fillStyle = "#808080";
        bctx.fillRect(0, 0, 256, 256);

        for (let i = 0; i < 2000; i++) {
          const x = Math.random() * 256;
          const y = Math.random() * 256;
          const size = 1 + Math.random() * 3;
          const shade = Math.floor(100 + Math.random() * 100);
          bctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
          bctx.beginPath();
          bctx.arc(x, y, size, 0, Math.PI * 2);
          bctx.fill();
        }

        const bumpTexture = new THREE.CanvasTexture(bumpCanvas);
        bumpTexture.wrapS = THREE.RepeatWrapping;
        bumpTexture.wrapT = THREE.RepeatWrapping;
        bumpTexture.repeat.set(20, 20);

        // Floor with texture
        const floor = new THREE.Mesh(
          new THREE.PlaneGeometry(200, 200),
          new THREE.MeshStandardMaterial({
            map: groundTexture,
            bumpMap: bumpTexture,
            bumpScale: 0.3,
            roughness: 0.95,
            metalness: 0.05,
          }),
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Roman pillars with fluted indents
        const marbleMat = new THREE.MeshStandardMaterial({
          color: 0xf5f0e6,
          emissive: 0x222218,
          emissiveIntensity: 0.1,
          roughness: 0.4,
          metalness: 0.1,
        });
        const goldMat = new THREE.MeshStandardMaterial({
          color: 0xd4af37,
          emissive: 0x8b7320,
          emissiveIntensity: 0.3,
          metalness: 0.8,
          roughness: 0.3,
        });

        [30, 55, 85].forEach((radius, tier) => {
          const count = 24 - tier * 6;
          const height = 60 + tier * 20;
          for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + tier * 0.2;
            const x = Math.cos(angle) * radius,
              z = Math.sin(angle) * radius;
            const pillar = new THREE.Group();

            // Base plinth
            const base = new THREE.Mesh(
              new THREE.BoxGeometry(2.5, 1.5, 2.5),
              marbleMat,
            );
            base.position.y = 0.75;
            base.castShadow = true;
            base.receiveShadow = true;
            pillar.add(base);

            // Fluted column with indents
            const fluteCount = 20;
            const columnRadius = 0.75;
            const fluteDepth = 0.08;

            // Create fluted column shape
            const columnShape = new THREE.Shape();
            for (let f = 0; f <= fluteCount; f++) {
              const a = (f / fluteCount) * Math.PI * 2;
              const nextA = ((f + 0.5) / fluteCount) * Math.PI * 2;
              const r = columnRadius;
              const rIn = columnRadius - fluteDepth;

              if (f === 0) {
                columnShape.moveTo(Math.cos(a) * r, Math.sin(a) * r);
              }
              // Outer ridge
              columnShape.lineTo(Math.cos(a) * r, Math.sin(a) * r);
              // Inner flute
              columnShape.quadraticCurveTo(
                Math.cos(nextA) * rIn,
                Math.sin(nextA) * rIn,
                Math.cos(((f + 1) / fluteCount) * Math.PI * 2) * r,
                Math.sin(((f + 1) / fluteCount) * Math.PI * 2) * r,
              );
            }

            const extrudeSettings = {
              steps: 1,
              depth: height,
              bevelEnabled: false,
            };

            const columnGeo = new THREE.ExtrudeGeometry(
              columnShape,
              extrudeSettings,
            );
            columnGeo.rotateX(-Math.PI / 2);
            const column = new THREE.Mesh(columnGeo, marbleMat);
            column.position.y = 1.5;
            column.castShadow = true;
            column.receiveShadow = true;
            pillar.add(column);

            // Capital (top piece)
            const cap = new THREE.Mesh(
              new THREE.CylinderGeometry(1.1, 0.85, 1.5, 24),
              marbleMat,
            );
            cap.position.y = 1.5 + height + 0.75;
            cap.castShadow = true;
            pillar.add(cap);

            // Gold decorative rings
            const ring1 = new THREE.Mesh(
              new THREE.TorusGeometry(0.95, 0.08, 8, 32),
              goldMat,
            );
            ring1.rotation.x = Math.PI / 2;
            ring1.position.y = 1.5 + height + 0.3;
            pillar.add(ring1);

            const ring2 = new THREE.Mesh(
              new THREE.TorusGeometry(1.0, 0.06, 8, 32),
              goldMat,
            );
            ring2.rotation.x = Math.PI / 2;
            ring2.position.y = 1.5 + height + 1.2;
            pillar.add(ring2);

            // Base ring
            const baseRing = new THREE.Mesh(
              new THREE.TorusGeometry(0.9, 0.1, 8, 32),
              goldMat,
            );
            baseRing.rotation.x = Math.PI / 2;
            baseRing.position.y = 1.6;
            pillar.add(baseRing);

            pillar.position.set(x, 0, z);
            scene.add(pillar);
          }
        });

        // Cosmic radiation streams
        for (let s = 0; s < 6; s++) {
          const positions = new Float32Array(200 * 3);
          const startAngle = (s / 6) * Math.PI * 2;
          const radius = 50 + Math.random() * 40;

          for (let i = 0; i < 200; i++) {
            const t = i / 200;
            const angle = startAngle + t * Math.PI * 0.5;
            const r = radius + Math.sin(t * Math.PI * 4) * 12;
            positions[i * 3] = Math.cos(angle) * r + (Math.random() - 0.5) * 8;
            positions[i * 3 + 1] = 8 + t * 30 + (Math.random() - 0.5) * 5;
            positions[i * 3 + 2] =
              Math.sin(angle) * r + (Math.random() - 0.5) * 8;
          }

          const geo = new THREE.BufferGeometry();
          geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
          const stream = new THREE.Points(
            geo,
            new THREE.PointsMaterial({
              color: s % 2 ? 0xffcc77 : 0xeebb88,
              size: 0.4,
              transparent: true,
              opacity: 0.7,
            }),
          );
          stream.userData = {
            speed: 0.0002 + Math.random() * 0.0002,
            dir: s % 2 ? 1 : -1,
          };
          scene.add(stream);
          radiationStreams.push(stream);
        }
      }

      function createPlayerMesh(color) {
        const g = new THREE.Group();

        // Core neon material
        const mat = new THREE.MeshStandardMaterial({
          color,
          emissive: color,
          emissiveIntensity: 0.7,
          metalness: 0.1,
          roughness: 0.2,
        });

        // Outer glow material
        const glowMat = new THREE.MeshBasicMaterial({
          color,
          transparent: true,
          opacity: 0.12,
          side: THREE.BackSide,
        });

        // Fluid body using a smooth curved shape (Lathe geometry for organic form)
        const bodyPoints = [];
        // Create smooth humanoid silhouette
        bodyPoints.push(new THREE.Vector2(0, 0)); // feet
        bodyPoints.push(new THREE.Vector2(0.06, 0.05)); // ankles
        bodyPoints.push(new THREE.Vector2(0.07, 0.2)); // calves
        bodyPoints.push(new THREE.Vector2(0.08, 0.35)); // knees
        bodyPoints.push(new THREE.Vector2(0.1, 0.55)); // thighs
        bodyPoints.push(new THREE.Vector2(0.12, 0.7)); // hips
        bodyPoints.push(new THREE.Vector2(0.13, 0.85)); // waist
        bodyPoints.push(new THREE.Vector2(0.14, 1.0)); // chest
        bodyPoints.push(new THREE.Vector2(0.12, 1.15)); // shoulders
        bodyPoints.push(new THREE.Vector2(0.06, 1.25)); // neck
        bodyPoints.push(new THREE.Vector2(0.12, 1.35)); // jaw
        bodyPoints.push(new THREE.Vector2(0.14, 1.45)); // head
        bodyPoints.push(new THREE.Vector2(0.12, 1.55)); // crown
        bodyPoints.push(new THREE.Vector2(0, 1.6)); // top

        const bodyGeo = new THREE.LatheGeometry(bodyPoints, 16);
        const body = new THREE.Mesh(bodyGeo, mat);
        g.add(body);

        // Body glow
        const glowPoints = bodyPoints.map(
          (p) => new THREE.Vector2(p.x + 0.06, p.y),
        );
        const glowGeo = new THREE.LatheGeometry(glowPoints, 16);
        const bodyGlow = new THREE.Mesh(glowGeo, glowMat);
        g.add(bodyGlow);

        // Fluid arms (curved tubes)
        const armCurveL = new THREE.CatmullRomCurve3([
          new THREE.Vector3(-0.14, 1.1, 0),
          new THREE.Vector3(-0.22, 0.95, 0.02),
          new THREE.Vector3(-0.25, 0.75, 0),
          new THREE.Vector3(-0.22, 0.55, -0.02),
        ]);
        const armCurveR = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0.14, 1.1, 0),
          new THREE.Vector3(0.22, 0.95, 0.02),
          new THREE.Vector3(0.25, 0.75, 0),
          new THREE.Vector3(0.22, 0.55, -0.02),
        ]);

        const armGeoL = new THREE.TubeGeometry(armCurveL, 12, 0.035, 8, false);
        const armGeoR = new THREE.TubeGeometry(armCurveR, 12, 0.035, 8, false);
        const leftArm = new THREE.Mesh(armGeoL, mat);
        const rightArm = new THREE.Mesh(armGeoR, mat);
        g.add(leftArm);
        g.add(rightArm);

        // Arm glow
        const armGlowGeoL = new THREE.TubeGeometry(
          armCurveL,
          12,
          0.06,
          8,
          false,
        );
        const armGlowGeoR = new THREE.TubeGeometry(
          armCurveR,
          12,
          0.06,
          8,
          false,
        );
        const leftArmGlow = new THREE.Mesh(armGlowGeoL, glowMat);
        const rightArmGlow = new THREE.Mesh(armGlowGeoR, glowMat);
        g.add(leftArmGlow);
        g.add(rightArmGlow);

        // Hands (soft spheres)
        const handMat = mat.clone();
        const lHand = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 12, 12),
          handMat,
        );
        lHand.position.set(-0.22, 0.55, -0.02);
        g.add(lHand);
        const rHand = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 12, 12),
          handMat,
        );
        rHand.position.set(0.22, 0.55, -0.02);
        g.add(rHand);

        // Neon point light
        const light = new THREE.PointLight(color, 1.2, 5);
        light.position.y = 1.0;
        g.add(light);

        // Outer aura
        const auraMat = new THREE.MeshBasicMaterial({
          color,
          transparent: true,
          opacity: 0.04,
          side: THREE.BackSide,
        });
        const aura = new THREE.Mesh(
          new THREE.SphereGeometry(0.7, 16, 16),
          auraMat,
        );
        aura.position.y = 0.8;
        g.add(aura);

        // Store refs for animation
        g.userData = {
          body,
          bodyGlow,
          leftArm,
          rightArm,
          leftArmGlow,
          rightArmGlow,
          lHand,
          rHand,
          aura,
          light,
          armCurveL,
          armCurveR,
          lastPos: { x: 0, z: 0 },
          walkPhase: Math.random() * Math.PI * 2,
          baseArmPointsL: armCurveL.points.map((p) => p.clone()),
          baseArmPointsR: armCurveR.points.map((p) => p.clone()),
        };

        return g;
      }

      function updatePlayerMesh(id, data) {
        if (id === state.playerId) return;
        if (!playerMeshes[id]) {
          playerMeshes[id] = createPlayerMesh(data.color);
          scene.add(playerMeshes[id]);
        }

        const m = playerMeshes[id];
        const u = m.userData;
        m.position.lerp(new THREE.Vector3(data.x, data.y - 1.8, data.z), 0.1);

        const dx = data.x - u.lastPos.x,
          dz = data.z - u.lastPos.z;
        const speed = Math.hypot(dx, dz);
        const isMoving = speed > 0.005;
        const time = performance.now() * 0.001;

        if (isMoving) {
          // Smooth rotation toward movement direction
          const targetRot = Math.atan2(dx, dz);
          const diff = Math.atan2(
            Math.sin(targetRot - m.rotation.y),
            Math.cos(targetRot - m.rotation.y),
          );
          m.rotation.y += diff * 0.1;

          // Walk cycle
          u.walkPhase += Math.min(speed * 15, 0.2);
          const phase = u.walkPhase;
          const swing = Math.sin(phase);
          const bounce = Math.abs(Math.sin(phase)) * 0.02;

          // Body sway and bounce
          u.body.position.y = bounce;
          u.body.rotation.z = swing * 0.03;
          u.body.rotation.y = swing * 0.05;
          u.bodyGlow.position.y = bounce;
          u.bodyGlow.rotation.z = swing * 0.03;

          // Fluid arm swing by updating curve control points
          const armSwing = swing * 0.15;
          const armForward = Math.sin(phase) * 0.12;

          // Update left arm curve
          u.armCurveL.points[1].z = 0.02 + armForward;
          u.armCurveL.points[2].z = armForward * 0.8;
          u.armCurveL.points[3].y = 0.55 + armSwing;
          u.armCurveL.points[3].z = -0.02 + armForward * 0.5;

          // Update right arm curve (opposite)
          u.armCurveR.points[1].z = 0.02 - armForward;
          u.armCurveR.points[2].z = -armForward * 0.8;
          u.armCurveR.points[3].y = 0.55 - armSwing;
          u.armCurveR.points[3].z = -0.02 - armForward * 0.5;

          // Rebuild arm geometry
          u.leftArm.geometry.dispose();
          u.rightArm.geometry.dispose();
          u.leftArmGlow.geometry.dispose();
          u.rightArmGlow.geometry.dispose();
          u.leftArm.geometry = new THREE.TubeGeometry(
            u.armCurveL,
            12,
            0.035,
            8,
            false,
          );
          u.rightArm.geometry = new THREE.TubeGeometry(
            u.armCurveR,
            12,
            0.035,
            8,
            false,
          );
          u.leftArmGlow.geometry = new THREE.TubeGeometry(
            u.armCurveL,
            12,
            0.06,
            8,
            false,
          );
          u.rightArmGlow.geometry = new THREE.TubeGeometry(
            u.armCurveR,
            12,
            0.06,
            8,
            false,
          );

          // Update hand positions
          u.lHand.position.copy(u.armCurveL.points[3]);
          u.rHand.position.copy(u.armCurveR.points[3]);

          // Aura pulses
          u.aura.scale.setScalar(1 + Math.sin(phase * 2) * 0.08);
          u.light.intensity = 1.2 + Math.sin(phase * 2) * 0.3;
        } else {
          // Idle animation - gentle breathing and sway
          const breathe = Math.sin(time * 1.2 + id.charCodeAt(7) * 0.5) * 0.01;
          const sway = Math.sin(time * 0.7 + id.charCodeAt(8) * 0.3) * 0.015;

          // Gentle body movement
          u.body.position.y = breathe;
          u.body.rotation.z = sway;
          u.body.rotation.y *= 0.95;
          u.bodyGlow.position.y = breathe;
          u.bodyGlow.rotation.z = sway;

          // Arms gently sway back to rest
          const restL = u.baseArmPointsL;
          const restR = u.baseArmPointsR;

          u.armCurveL.points[1].lerp(restL[1], 0.05);
          u.armCurveL.points[2].lerp(restL[2], 0.05);
          u.armCurveL.points[3].lerp(restL[3], 0.05);
          u.armCurveR.points[1].lerp(restR[1], 0.05);
          u.armCurveR.points[2].lerp(restR[2], 0.05);
          u.armCurveR.points[3].lerp(restR[3], 0.05);

          // Subtle idle arm sway
          u.armCurveL.points[3].x = restL[3].x + sway * 0.5;
          u.armCurveR.points[3].x = restR[3].x + sway * 0.5;

          // Rebuild arm geometry
          u.leftArm.geometry.dispose();
          u.rightArm.geometry.dispose();
          u.leftArmGlow.geometry.dispose();
          u.rightArmGlow.geometry.dispose();
          u.leftArm.geometry = new THREE.TubeGeometry(
            u.armCurveL,
            12,
            0.035,
            8,
            false,
          );
          u.rightArm.geometry = new THREE.TubeGeometry(
            u.armCurveR,
            12,
            0.035,
            8,
            false,
          );
          u.leftArmGlow.geometry = new THREE.TubeGeometry(
            u.armCurveL,
            12,
            0.06,
            8,
            false,
          );
          u.rightArmGlow.geometry = new THREE.TubeGeometry(
            u.armCurveR,
            12,
            0.06,
            8,
            false,
          );

          u.lHand.position.copy(u.armCurveL.points[3]);
          u.rHand.position.copy(u.armCurveR.points[3]);

          // Gentle aura pulse
          u.aura.scale.setScalar(1 + Math.sin(time * 1.5) * 0.04);
          u.light.intensity = 1.2 + Math.sin(time * 1.5) * 0.15;
        }

        u.lastPos = { x: data.x, z: data.z };
      }

      function initFirebase() {
        const ref = database.ref("players/" + state.playerId);
        ref.set({
          x: 0,
          y: 2,
          z: 0,
          color: state.playerColor,
          lastUpdate: firebase.database.ServerValue.TIMESTAMP,
        });
        ref.onDisconnect().remove();

        // Clean up on page unload (backup for onDisconnect)
        window.addEventListener("beforeunload", () => ref.remove());
        window.addEventListener("unload", () => ref.remove());
        window.addEventListener("pagehide", () => ref.remove());

        // Also handle visibility change (mobile tab switch)
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            ref.update({ lastUpdate: firebase.database.ServerValue.TIMESTAMP });
          }
        });

        database.ref("players").on("value", (snap) => {
          const players = snap.val() || {};
          const now = Date.now();

          // Remove stale players (no update in 10 seconds)
          Object.entries(players).forEach(([id, data]) => {
            if (data.lastUpdate && now - data.lastUpdate > 10000) {
              database.ref("players/" + id).remove();
              delete players[id];
            }
          });

          document.getElementById("playerCount").textContent =
            Object.keys(players).length;

          // Remove meshes for disconnected players
          Object.keys(playerMeshes).forEach((id) => {
            if (!players[id]) {
              // Dispose of geometries to free memory
              playerMeshes[id].traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                  if (Array.isArray(child.material)) {
                    child.material.forEach((m) => m.dispose());
                  } else {
                    child.material.dispose();
                  }
                }
              });
              scene.remove(playerMeshes[id]);
              delete playerMeshes[id];
            }
          });

          // Update existing players
          Object.entries(players).forEach(([id, data]) =>
            updatePlayerMesh(id, data),
          );
        });
      }

      function initControls() {
        const setKey = (e, val) => {
          const k = e.key.toLowerCase();
          if (k in state.keys) state.keys[k] = val;
          if (e.key === "Shift") state.keys.shift = val;
        };
        document.addEventListener("keydown", (e) => setKey(e, true));
        document.addEventListener("keyup", (e) => setKey(e, false));

        if (!state.isMobile) {
          document.addEventListener("click", () =>
            renderer.domElement.requestPointerLock(),
          );
          document.addEventListener("mousemove", (e) => {
            if (document.pointerLockElement === renderer.domElement) {
              state.rotation.y -= e.movementX * 0.002;
              state.rotation.x = Math.max(
                -Math.PI / 2,
                Math.min(Math.PI / 2, state.rotation.x - e.movementY * 0.002),
              );
            }
          });
        } else {
          const jZone = document.getElementById("joystickZone");
          const jCont = document.getElementById("joystickContainer");
          const jKnob = document.getElementById("joystickKnob");
          const lZone = document.getElementById("lookZone");
          let jOrigin = { x: 0, y: 0 },
            lOrigin = { x: 0, y: 0 },
            lTouchId = null;

          jZone.addEventListener("touchstart", (e) => {
            e.preventDefault();
            state.joystick.active = true;
            jOrigin = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            jCont.style.left = jOrigin.x - 60 + "px";
            jCont.style.bottom = innerHeight - jOrigin.y - 60 + "px";
            jCont.style.display = "flex";
          });
          jZone.addEventListener("touchmove", (e) => {
            if (!state.joystick.active) return;
            const dx = e.touches[0].clientX - jOrigin.x,
              dy = e.touches[0].clientY - jOrigin.y;
            const dist = Math.min(Math.hypot(dx, dy), 50),
              ang = Math.atan2(dy, dx);
            jKnob.style.transform = `translate(${Math.cos(ang) * dist}px, ${Math.sin(ang) * dist}px)`;
            state.joystick.x = (Math.cos(ang) * dist) / 50;
            state.joystick.y = (Math.sin(ang) * dist) / 50;
          });
          jZone.addEventListener("touchend", () => {
            state.joystick = { active: false, x: 0, y: 0 };
            jKnob.style.transform = "translate(0,0)";
            jCont.style.display = "none";
          });

          lZone.addEventListener("touchstart", (e) => {
            lTouchId = e.changedTouches[0].identifier;
            lOrigin = {
              x: e.changedTouches[0].clientX,
              y: e.changedTouches[0].clientY,
            };
          });
          lZone.addEventListener("touchmove", (e) => {
            for (let t of e.changedTouches) {
              if (t.identifier === lTouchId) {
                state.rotation.y -= (t.clientX - lOrigin.x) * 0.005;
                state.rotation.x = Math.max(
                  -Math.PI / 2,
                  Math.min(
                    Math.PI / 2,
                    state.rotation.x - (t.clientY - lOrigin.y) * 0.005,
                  ),
                );
                lOrigin = { x: t.clientX, y: t.clientY };
              }
            }
          });
          lZone.addEventListener("touchend", (e) => {
            for (let t of e.changedTouches)
              if (t.identifier === lTouchId) lTouchId = null;
          });
        }
      }

      let lastSync = 0;
      function gameLoop() {
        requestAnimationFrame(gameLoop);

        const speed = state.keys.shift ? 0.03 : 0.0225;
        let mx = 0,
          mz = 0;
        if (state.isMobile && state.joystick.active) {
          mx = state.joystick.x;
          mz = state.joystick.y;
        } else {
          if (state.keys.w) mz--;
          if (state.keys.s) mz++;
          if (state.keys.a) mx--;
          if (state.keys.d) mx++;
        }

        const len = Math.hypot(mx, mz);
        if (len > 0) {
          mx /= len;
          mz /= len;
        }

        const sin = Math.sin(state.rotation.y),
          cos = Math.cos(state.rotation.y);
        state.velocity.x =
          (state.velocity.x + (mz * sin + mx * cos) * speed) * 0.88;
        state.velocity.z =
          (state.velocity.z + (mz * cos - mx * sin) * speed) * 0.88;
        state.position.x += state.velocity.x;
        state.position.z += state.velocity.z;

        camera.position.set(
          state.position.x,
          state.position.y,
          state.position.z,
        );
        camera.rotation.order = "YXZ";
        camera.rotation.y = state.rotation.y;
        camera.rotation.x = state.rotation.x;

        radiationStreams.forEach(
          (s) => (s.rotation.y += s.userData.speed * s.userData.dir),
        );

        if (Date.now() - lastSync > 50) {
          database
            .ref("players/" + state.playerId)
            .update({
              x: state.position.x,
              y: state.position.y,
              z: state.position.z,
              lastUpdate: firebase.database.ServerValue.TIMESTAMP,
            });
          lastSync = Date.now();
        }

        renderer.render(scene, camera);
      }

      function init() {
        document.getElementById("yourColor").style.backgroundColor =
          state.playerColor;
        document.getElementById("yourColor").style.color = state.playerColor;
        initThree();
        initControls();
        initFirebase();
        setTimeout(
          () => document.getElementById("loading").classList.add("hidden"),
          1500,
        );
        gameLoop();
      }

      document.readyState === "loading"
        ? document.addEventListener("DOMContentLoaded", init)
        : init();
    </script>
  </body>
</html>
