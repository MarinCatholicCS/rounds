<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Void Space</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Rajdhani', sans-serif;
            touch-action: none;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        canvas {
            display: block;
        }
        
        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }
        
        .ui-overlay * {
            pointer-events: auto;
        }
        
        /* Header */
        .header {
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .logo {
            font-family: 'Orbitron', monospace;
            font-size: 1.4rem;
            font-weight: 700;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
        }
        
        .logo span {
            opacity: 0.4;
            font-weight: 400;
        }
        
        .player-count {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            letter-spacing: 0.1em;
            backdrop-filter: blur(10px);
        }
        
        .player-count strong {
            color: #fff;
            font-weight: 500;
        }
        
        /* Controls hint */
        .controls-hint {
            bottom: 30px;
            left: 30px;
            color: rgba(255,255,255,0.3);
            font-size: 0.8rem;
            letter-spacing: 0.05em;
        }
        
        .controls-hint kbd {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 4px 10px;
            border-radius: 4px;
            margin: 0 3px;
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
        }
        
        /* Mobile joystick */
        .joystick-zone {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 50%;
            height: 40%;
            z-index: 50;
        }
        
        .joystick-container {
            position: absolute;
            bottom: 80px;
            left: 60px;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .joystick-knob {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4), rgba(255,255,255,0.1));
            border-radius: 50%;
            transition: transform 0.05s ease-out;
        }
        
        /* Look zone for camera */
        .look-zone {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 50%;
            height: 40%;
            z-index: 50;
        }
        
        /* Your color indicator */
        .your-color {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 12px;
            color: rgba(255,255,255,0.5);
            font-size: 0.8rem;
            letter-spacing: 0.05em;
        }
        
        .color-orb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            box-shadow: 0 0 20px currentColor, inset 0 0 10px rgba(255,255,255,0.3);
        }
        
        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s ease, visibility 0.8s;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .loading-text {
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            color: rgba(255,255,255,0.6);
            letter-spacing: 0.5em;
            margin-top: 30px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        .loading-ring {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255,255,255,0.1);
            border-top-color: rgba(255,255,255,0.8);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        /* Mobile styles */
        @media (max-width: 768px) {
            .header {
                padding: 15px 20px;
            }
            
            .logo {
                font-size: 1rem;
            }
            
            .player-count {
                font-size: 0.75rem;
                padding: 8px 15px;
            }
            
            .controls-hint {
                display: none;
            }
            
            .joystick-container {
                display: flex;
            }
            
            .your-color {
                bottom: auto;
                top: 70px;
                right: 20px;
            }
        }
        
        /* Name tags */
        .nametag {
            position: absolute;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            white-space: nowrap;
            transform: translate(-50%, -100%);
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loading">
        <div class="loading-ring"></div>
        <div class="loading-text">ENTERING VOID</div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>
    
    <!-- UI Overlays -->
    <div class="ui-overlay header">
        <div class="logo">VOID<span>SPACE</span></div>
        <div class="player-count">
            <strong id="playerCount">0</strong> IN VOID
        </div>
    </div>
    
    <div class="ui-overlay controls-hint">
        <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> MOVE Â· <kbd>MOUSE</kbd> LOOK
    </div>
    
    <div class="your-color">
        YOUR ESSENCE <div class="color-orb" id="yourColor"></div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="joystick-zone" id="joystickZone">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>
    <div class="look-zone" id="lookZone"></div>
    
    <!-- Nametags container -->
    <div id="nametags"></div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDI9HGn4Dzd00Q_zLQZMRapI3Z8wX7ltHw",
            authDomain: "interact-mc.firebaseapp.com",
            databaseURL: "https://interact-mc-default-rtdb.firebaseio.com",
            projectId: "interact-mc",
            storageBucket: "interact-mc.firebasestorage.app",
            messagingSenderId: "336656676684",
            appId: "1:336656676684:web:8b348d7a2a9529b42ac1e9",
            measurementId: "G-4W59B6XST2"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // ============== GAME STATE ==============
        const state = {
            playerId: 'player_' + Math.random().toString(36).substr(2, 9),
            playerColor: generateVibrantColor(),
            position: { x: 0, y: 2, z: 0 },
            rotation: { x: 0, y: 0 },
            velocity: { x: 0, y: 0, z: 0 },
            players: {},
            keys: { w: false, a: false, s: false, d: false, shift: false },
            isMobile: /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            joystick: { active: false, x: 0, y: 0 },
            lookDelta: { x: 0, y: 0 },
            mouseSensitivity: 0.002,
            touchSensitivity: 0.005,
            moveSpeed: 0.15,
            friction: 0.85
        };

        // Generate vibrant, distinct colors
        function generateVibrantColor() {
            const hue = Math.random() * 360;
            const saturation = 70 + Math.random() * 30;
            const lightness = 50 + Math.random() * 20;
            return hslToHex(hue, saturation, lightness);
        }

        function hslToHex(h, s, l) {
            s /= 100;
            l /= 100;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        // ============== THREE.JS SETUP ==============
        let scene, camera, renderer, playerMeshes = {};

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xfff8f0, 0.006);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(state.position.x, state.position.y, state.position.z);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x1a1520);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting - bright and visible
            const ambientLight = new THREE.AmbientLight(0x6666aa, 1.2);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1.2, 200);
            pointLight.position.set(0, 40, 0);
            scene.add(pointLight);
            
            // Hemisphere light for even illumination
            const hemiLight = new THREE.HemisphereLight(0x8888cc, 0x444466, 1.0);
            scene.add(hemiLight);
            
            // Violet accent light
            const violetLight = new THREE.PointLight(0xaa77ff, 0.8, 250);
            violetLight.position.set(-50, 60, -50);
            scene.add(violetLight);
            
            // Warm tan light from the other side
            const tanLight = new THREE.PointLight(0xffcc88, 0.6, 250);
            tanLight.position.set(60, 50, 60);
            scene.add(tanLight);

            // Ground grid
            createEnvironment();

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createEnvironment() {
            // Marble floor grid
            const gridHelper = new THREE.GridHelper(200, 50, 0x8a8070, 0x3a3530);
            gridHelper.position.y = 0;
            scene.add(gridHelper);
            
            // Add a subtle floor plane
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2520,
                metalness: 0.2,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.01;
            scene.add(floor);

            // Scattered ambient particles (stars)
            const particleCount = 800;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 300;
                positions[i * 3 + 1] = Math.random() * 80 + 5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                
                // Mix of white, violet, and tan stars
                const colorChoice = Math.random();
                if (colorChoice < 0.5) {
                    colors[i * 3] = 0.9; colors[i * 3 + 1] = 0.85; colors[i * 3 + 2] = 1.0; // White-violet
                } else if (colorChoice < 0.75) {
                    colors[i * 3] = 0.7; colors[i * 3 + 1] = 0.5; colors[i * 3 + 2] = 1.0; // Violet
                } else {
                    colors[i * 3] = 1.0; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 0.7; // Tan
                }
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.15,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                vertexColors: true
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Tan cosmic radiation clouds (as particle clusters, not nebulae)
            createCosmicRadiation();

            // Grand Roman pillars reaching into the heavens
            createRomanPillars();
            
            // Heavenly fog above
            createHeavenlyFog();
        }
        
        function createRomanPillars() {
            const pillarCount = 24;
            const ringRadii = [30, 55, 85];
            
            ringRadii.forEach((radius, ringIndex) => {
                const pillarsInRing = pillarCount - ringIndex * 6;
                
                for (let i = 0; i < pillarsInRing; i++) {
                    const angle = (i / pillarsInRing) * Math.PI * 2 + ringIndex * 0.2;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    createRomanPillar(x, z, ringIndex);
                }
            });
        }
        
        function createRomanPillar(x, z, tier) {
            const pillarGroup = new THREE.Group();
            const pillarHeight = 60 + tier * 20;
            
            // Marble-like material
            const marbleMaterial = new THREE.MeshStandardMaterial({
                color: 0xf5f0e6,
                emissive: 0x222218,
                emissiveIntensity: 0.1,
                metalness: 0.1,
                roughness: 0.6
            });
            
            const goldMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4af37,
                emissive: 0x8b7320,
                emissiveIntensity: 0.3,
                metalness: 0.8,
                roughness: 0.3
            });
            
            // Base (square plinth)
            const baseGeometry = new THREE.BoxGeometry(2.5, 1, 2.5);
            const base = new THREE.Mesh(baseGeometry, marbleMaterial);
            base.position.y = 0.5;
            pillarGroup.add(base);
            
            // Second base tier
            const base2Geometry = new THREE.BoxGeometry(2.2, 0.5, 2.2);
            const base2 = new THREE.Mesh(base2Geometry, marbleMaterial);
            base2.position.y = 1.25;
            pillarGroup.add(base2);
            
            // Torus base decoration
            const torusGeometry = new THREE.TorusGeometry(1, 0.15, 8, 24);
            const torus = new THREE.Mesh(torusGeometry, goldMaterial);
            torus.rotation.x = Math.PI / 2;
            torus.position.y = 1.7;
            pillarGroup.add(torus);
            
            // Main column (fluted effect with multiple cylinders)
            const columnRadius = 0.8;
            const fluteCount = 20;
            
            // Main cylinder
            const columnGeometry = new THREE.CylinderGeometry(columnRadius, columnRadius * 1.1, pillarHeight, 24);
            const column = new THREE.Mesh(columnGeometry, marbleMaterial);
            column.position.y = 2 + pillarHeight / 2;
            pillarGroup.add(column);
            
            // Fluting (vertical grooves)
            for (let f = 0; f < fluteCount; f++) {
                const fluteAngle = (f / fluteCount) * Math.PI * 2;
                const fluteGeometry = new THREE.CylinderGeometry(0.08, 0.08, pillarHeight - 2, 8);
                const fluteMaterial = new THREE.MeshStandardMaterial({
                    color: 0xe8e0d0,
                    metalness: 0.1,
                    roughness: 0.7
                });
                const flute = new THREE.Mesh(fluteGeometry, fluteMaterial);
                flute.position.set(
                    Math.cos(fluteAngle) * (columnRadius + 0.02),
                    2 + pillarHeight / 2,
                    Math.sin(fluteAngle) * (columnRadius + 0.02)
                );
                pillarGroup.add(flute);
            }
            
            // Capital (Corinthian-style simplified)
            const capitalBase = new THREE.Mesh(
                new THREE.CylinderGeometry(1, columnRadius, 1, 24),
                marbleMaterial
            );
            capitalBase.position.y = 2 + pillarHeight + 0.5;
            pillarGroup.add(capitalBase);
            
            // Capital decorative rings
            for (let r = 0; r < 3; r++) {
                const ringGeom = new THREE.TorusGeometry(0.9 - r * 0.1, 0.08, 8, 24);
                const ring = new THREE.Mesh(ringGeom, goldMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 2 + pillarHeight + 0.3 + r * 0.3;
                pillarGroup.add(ring);
            }
            
            // Abacus (top slab)
            const abacusGeometry = new THREE.BoxGeometry(2.2, 0.4, 2.2);
            const abacus = new THREE.Mesh(abacusGeometry, marbleMaterial);
            abacus.position.y = 2 + pillarHeight + 1.3;
            pillarGroup.add(abacus);
            
            // Ethereal glow at the top (fading into heaven)
            const glowGeometry = new THREE.CylinderGeometry(1.5, 0.5, 15, 16, 1, true);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xfff8e7,
                transparent: true,
                opacity: 0.08,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 2 + pillarHeight + 8;
            pillarGroup.add(glow);
            
            pillarGroup.position.set(x, 0, z);
            scene.add(pillarGroup);
        }
        
        function createHeavenlyFog() {
            // Multiple layers of fog planes at different heights
            const fogLayers = [
                { height: 50, opacity: 0.03, size: 400 },
                { height: 60, opacity: 0.05, size: 450 },
                { height: 70, opacity: 0.08, size: 500 },
                { height: 80, opacity: 0.12, size: 550 },
                { height: 95, opacity: 0.2, size: 600 },
                { height: 110, opacity: 0.35, size: 650 },
                { height: 130, opacity: 0.5, size: 700 },
            ];
            
            fogLayers.forEach(layer => {
                const fogGeometry = new THREE.PlaneGeometry(layer.size, layer.size);
                const fogMaterial = new THREE.MeshBasicMaterial({
                    color: 0xfff9f0,
                    transparent: true,
                    opacity: layer.opacity,
                    side: THREE.DoubleSide
                });
                const fogPlane = new THREE.Mesh(fogGeometry, fogMaterial);
                fogPlane.rotation.x = Math.PI / 2;
                fogPlane.position.y = layer.height;
                scene.add(fogPlane);
            });
            
            // Volumetric fog particles drifting
            const fogParticleCount = 1000;
            const fogParticleGeometry = new THREE.BufferGeometry();
            const fogPositions = new Float32Array(fogParticleCount * 3);
            const fogSizes = new Float32Array(fogParticleCount);
            
            for (let i = 0; i < fogParticleCount; i++) {
                fogPositions[i * 3] = (Math.random() - 0.5) * 300;
                fogPositions[i * 3 + 1] = 40 + Math.random() * 70;
                fogPositions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                fogSizes[i] = 2 + Math.random() * 4;
            }
            
            fogParticleGeometry.setAttribute('position', new THREE.BufferAttribute(fogPositions, 3));
            
            const fogParticleMaterial = new THREE.PointsMaterial({
                color: 0xfffff5,
                size: 3,
                transparent: true,
                opacity: 0.15,
                sizeAttenuation: true
            });
            
            const fogParticles = new THREE.Points(fogParticleGeometry, fogParticleMaterial);
            fogParticles.userData.isHeavenlyFog = true;
            scene.add(fogParticles);
            heavenlyFogParticles = fogParticles;
            
            // Golden light rays from above
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = 20 + Math.random() * 60;
                
                const rayGeometry = new THREE.CylinderGeometry(0.5, 3, 80, 8, 1, true);
                const rayMaterial = new THREE.MeshBasicMaterial({
                    color: 0xfff4d4,
                    transparent: true,
                    opacity: 0.04,
                    side: THREE.DoubleSide
                });
                const ray = new THREE.Mesh(rayGeometry, rayMaterial);
                ray.position.set(
                    Math.cos(angle) * radius,
                    90,
                    Math.sin(angle) * radius
                );
                scene.add(ray);
            }
            
            // Bright heavenly light from above
            const heavenLight = new THREE.PointLight(0xfff8e0, 1.5, 300);
            heavenLight.position.set(0, 120, 0);
            scene.add(heavenLight);
            
            const heavenLight2 = new THREE.DirectionalLight(0xfff5e6, 0.8);
            heavenLight2.position.set(0, 100, 0);
            scene.add(heavenLight2);
        }
        
        let heavenlyFogParticles = null;

        // Create cosmic radiation streams
        function createCosmicRadiation() {
            const streamCount = 8;
            
            for (let s = 0; s < streamCount; s++) {
                const particleCount = 300;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                const startAngle = (s / streamCount) * Math.PI * 2;
                const radius = 40 + Math.random() * 50;
                const height = 5 + Math.random() * 25;
                
                for (let i = 0; i < particleCount; i++) {
                    const t = i / particleCount;
                    const angle = startAngle + t * Math.PI * 0.6;
                    const r = radius + Math.sin(t * Math.PI * 5) * 15;
                    
                    positions[i * 3] = Math.cos(angle) * r + (Math.random() - 0.5) * 10;
                    positions[i * 3 + 1] = height + t * 25 + (Math.random() - 0.5) * 6;
                    positions[i * 3 + 2] = Math.sin(angle) * r + (Math.random() - 0.5) * 10;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: s % 2 === 0 ? 0xffcc77 : 0xeebb88,
                    size: 0.4,
                    transparent: true,
                    opacity: 0.7,
                    sizeAttenuation: true
                });
                
                const stream = new THREE.Points(geometry, material);
                stream.userData = { 
                    rotationSpeed: 0.00015 + Math.random() * 0.00025,
                    direction: s % 2 === 0 ? 1 : -1
                };
                scene.add(stream);
                radiationStreams.push(stream);
            }
        }

        // Animation arrays
        let radiationStreams = [];

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============== PLAYER RENDERING ==============
        function createPlayerMesh(color) {
            const playerGroup = new THREE.Group();
            
            // Material for glowing neon effect
            const neonMaterial = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                metalness: 0.3,
                roughness: 0.4
            });
            
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });

            // Head (sphere)
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const head = new THREE.Mesh(headGeometry, neonMaterial);
            head.position.y = 1.6;
            playerGroup.add(head);
            
            // Head glow
            const headGlow = new THREE.Mesh(new THREE.SphereGeometry(0.32, 16, 16), glowMaterial);
            headGlow.position.y = 1.6;
            playerGroup.add(headGlow);

            // Torso (capsule-like: cylinder + spheres)
            const torsoGeometry = new THREE.CylinderGeometry(0.2, 0.15, 0.6, 8);
            const torso = new THREE.Mesh(torsoGeometry, neonMaterial);
            torso.position.y = 1.1;
            playerGroup.add(torso);
            
            // Torso glow
            const torsoGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.26, 0.21, 0.65, 8), glowMaterial);
            torsoGlow.position.y = 1.1;
            playerGroup.add(torsoGlow);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.06, 0.05, 0.5, 8);
            
            // Left arm
            const leftArm = new THREE.Mesh(armGeometry, neonMaterial);
            leftArm.position.set(-0.3, 1.1, 0);
            leftArm.rotation.z = 0.2;
            playerGroup.add(leftArm);
            
            const leftArmGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.08, 0.52, 8), glowMaterial);
            leftArmGlow.position.set(-0.3, 1.1, 0);
            leftArmGlow.rotation.z = 0.2;
            playerGroup.add(leftArmGlow);
            
            // Right arm
            const rightArm = new THREE.Mesh(armGeometry, neonMaterial);
            rightArm.position.set(0.3, 1.1, 0);
            rightArm.rotation.z = -0.2;
            playerGroup.add(rightArm);
            
            const rightArmGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.08, 0.52, 8), glowMaterial);
            rightArmGlow.position.set(0.3, 1.1, 0);
            rightArmGlow.rotation.z = -0.2;
            playerGroup.add(rightArmGlow);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.07, 0.05, 0.6, 8);
            
            // Left leg
            const leftLeg = new THREE.Mesh(legGeometry, neonMaterial);
            leftLeg.position.set(-0.1, 0.5, 0);
            playerGroup.add(leftLeg);
            
            const leftLegGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.62, 8), glowMaterial);
            leftLegGlow.position.set(-0.1, 0.5, 0);
            playerGroup.add(leftLegGlow);
            
            // Right leg
            const rightLeg = new THREE.Mesh(legGeometry, neonMaterial);
            rightLeg.position.set(0.1, 0.5, 0);
            playerGroup.add(rightLeg);
            
            const rightLegGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.62, 8), glowMaterial);
            rightLegGlow.position.set(0.1, 0.5, 0);
            playerGroup.add(rightLegGlow);

            // Hands (small spheres)
            const handGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            
            const leftHand = new THREE.Mesh(handGeometry, neonMaterial);
            leftHand.position.set(-0.35, 0.82, 0);
            playerGroup.add(leftHand);
            
            const rightHand = new THREE.Mesh(handGeometry, neonMaterial);
            rightHand.position.set(0.35, 0.82, 0);
            playerGroup.add(rightHand);

            // Feet (small spheres)
            const footGeometry = new THREE.SphereGeometry(0.07, 8, 8);
            
            const leftFoot = new THREE.Mesh(footGeometry, neonMaterial);
            leftFoot.position.set(-0.1, 0.18, 0.03);
            playerGroup.add(leftFoot);
            
            const rightFoot = new THREE.Mesh(footGeometry, neonMaterial);
            rightFoot.position.set(0.1, 0.18, 0.03);
            playerGroup.add(rightFoot);

            // Point light for neon glow effect
            const light = new THREE.PointLight(color, 0.8, 8);
            light.position.y = 1.1;
            playerGroup.add(light);

            // Store references for animation
            playerGroup.userData.leftArm = leftArm;
            playerGroup.userData.rightArm = rightArm;
            playerGroup.userData.leftLeg = leftLeg;
            playerGroup.userData.rightLeg = rightLeg;
            playerGroup.userData.leftArmGlow = leftArmGlow;
            playerGroup.userData.rightArmGlow = rightArmGlow;
            playerGroup.userData.leftLegGlow = leftLegGlow;
            playerGroup.userData.rightLegGlow = rightLegGlow;
            playerGroup.userData.lastPos = { x: 0, z: 0 };
            playerGroup.userData.animPhase = Math.random() * Math.PI * 2;

            return playerGroup;
        }

        function updatePlayerMesh(playerId, data) {
            if (playerId === state.playerId) return;

            if (!playerMeshes[playerId]) {
                playerMeshes[playerId] = createPlayerMesh(data.color);
                scene.add(playerMeshes[playerId]);
            }

            const mesh = playerMeshes[playerId];
            const targetPos = new THREE.Vector3(data.x, data.y - 1.8, data.z);
            
            // Calculate movement for animation
            const lastPos = mesh.userData.lastPos;
            const dx = data.x - lastPos.x;
            const dz = data.z - lastPos.z;
            const isMoving = Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01;
            
            // Smooth position interpolation
            mesh.position.lerp(targetPos, 0.15);
            
            // Rotate to face movement direction
            if (isMoving) {
                const targetRotation = Math.atan2(dx, dz);
                mesh.rotation.y = targetRotation;
                
                // Walking animation
                mesh.userData.animPhase += 0.2;
                const swing = Math.sin(mesh.userData.animPhase) * 0.4;
                
                // Animate arms
                mesh.userData.leftArm.rotation.x = swing;
                mesh.userData.rightArm.rotation.x = -swing;
                mesh.userData.leftArmGlow.rotation.x = swing;
                mesh.userData.rightArmGlow.rotation.x = -swing;
                
                // Animate legs
                mesh.userData.leftLeg.rotation.x = -swing;
                mesh.userData.rightLeg.rotation.x = swing;
                mesh.userData.leftLegGlow.rotation.x = -swing;
                mesh.userData.rightLegGlow.rotation.x = swing;
            } else {
                // Idle - return to neutral
                mesh.userData.leftArm.rotation.x *= 0.9;
                mesh.userData.rightArm.rotation.x *= 0.9;
                mesh.userData.leftLeg.rotation.x *= 0.9;
                mesh.userData.rightLeg.rotation.x *= 0.9;
                mesh.userData.leftArmGlow.rotation.x *= 0.9;
                mesh.userData.rightArmGlow.rotation.x *= 0.9;
                mesh.userData.leftLegGlow.rotation.x *= 0.9;
                mesh.userData.rightLegGlow.rotation.x *= 0.9;
            }
            
            mesh.userData.lastPos = { x: data.x, z: data.z };
        }

        function removePlayerMesh(playerId) {
            if (playerMeshes[playerId]) {
                scene.remove(playerMeshes[playerId]);
                delete playerMeshes[playerId];
            }
        }

        // ============== FIREBASE SYNC ==============
        function initFirebase() {
            const playerRef = database.ref('players/' + state.playerId);
            const playersRef = database.ref('players');

            // Set initial position
            playerRef.set({
                x: state.position.x,
                y: state.position.y,
                z: state.position.z,
                color: state.playerColor,
                lastUpdate: firebase.database.ServerValue.TIMESTAMP
            });

            // Remove on disconnect
            playerRef.onDisconnect().remove();

            // Listen for all players
            playersRef.on('value', (snapshot) => {
                const players = snapshot.val() || {};
                state.players = players;
                
                // Update player count
                document.getElementById('playerCount').textContent = Object.keys(players).length;

                // Remove disconnected players
                for (const id in playerMeshes) {
                    if (!players[id]) {
                        removePlayerMesh(id);
                    }
                }

                // Update/add players
                for (const id in players) {
                    updatePlayerMesh(id, players[id]);
                }
            });
        }

        function syncPosition() {
            database.ref('players/' + state.playerId).update({
                x: state.position.x,
                y: state.position.y,
                z: state.position.z,
                lastUpdate: firebase.database.ServerValue.TIMESTAMP
            });
        }

        // ============== CONTROLS ==============
        function initControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (state.keys.hasOwnProperty(key)) {
                    state.keys[key] = true;
                }
                if (e.key === 'Shift') state.keys.shift = true;
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (state.keys.hasOwnProperty(key)) {
                    state.keys[key] = false;
                }
                if (e.key === 'Shift') state.keys.shift = false;
            });

            // Mouse look (desktop)
            if (!state.isMobile) {
                document.addEventListener('click', () => {
                    renderer.domElement.requestPointerLock();
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === renderer.domElement) {
                        state.rotation.y -= e.movementX * state.mouseSensitivity;
                        state.rotation.x -= e.movementY * state.mouseSensitivity;
                        state.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, state.rotation.x));
                    }
                });
            }

            // Mobile controls
            if (state.isMobile) {
                initMobileControls();
            }
        }

        function initMobileControls() {
            const joystickZone = document.getElementById('joystickZone');
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickKnob = document.getElementById('joystickKnob');
            const lookZone = document.getElementById('lookZone');

            let joystickOrigin = { x: 0, y: 0 };
            let lookOrigin = { x: 0, y: 0 };
            let lookTouchId = null;

            // Joystick touch
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                state.joystick.active = true;
                joystickOrigin = { x: touch.clientX, y: touch.clientY };
                
                joystickContainer.style.left = (touch.clientX - 60) + 'px';
                joystickContainer.style.bottom = (window.innerHeight - touch.clientY - 60) + 'px';
                joystickContainer.style.display = 'flex';
            });

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!state.joystick.active) return;
                
                const touch = e.touches[0];
                const dx = touch.clientX - joystickOrigin.x;
                const dy = touch.clientY - joystickOrigin.y;
                const distance = Math.min(Math.sqrt(dx * dx + dy * dy), 50);
                const angle = Math.atan2(dy, dx);
                
                const knobX = Math.cos(angle) * distance;
                const knobY = Math.sin(angle) * distance;
                
                joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
                
                state.joystick.x = knobX / 50;
                state.joystick.y = knobY / 50;
            });

            joystickZone.addEventListener('touchend', (e) => {
                state.joystick.active = false;
                state.joystick.x = 0;
                state.joystick.y = 0;
                joystickKnob.style.transform = 'translate(0, 0)';
                joystickContainer.style.display = 'none';
            });

            // Look touch
            lookZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                lookTouchId = touch.identifier;
                lookOrigin = { x: touch.clientX, y: touch.clientY };
            });

            lookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    if (touch.identifier === lookTouchId) {
                        const dx = touch.clientX - lookOrigin.x;
                        const dy = touch.clientY - lookOrigin.y;
                        
                        state.rotation.y -= dx * state.touchSensitivity;
                        state.rotation.x -= dy * state.touchSensitivity;
                        state.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, state.rotation.x));
                        
                        lookOrigin = { x: touch.clientX, y: touch.clientY };
                    }
                }
            });

            lookZone.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === lookTouchId) {
                        lookTouchId = null;
                    }
                }
            });
        }

        // ============== GAME LOOP ==============
        function updateMovement() {
            const speed = state.keys.shift ? state.moveSpeed * 1.5 : state.moveSpeed;
            
            // Get movement direction from keys or joystick
            let moveX = 0;
            let moveZ = 0;

            if (state.isMobile && state.joystick.active) {
                moveX = state.joystick.x;
                moveZ = state.joystick.y;
            } else {
                if (state.keys.w) moveZ -= 1;
                if (state.keys.s) moveZ += 1;
                if (state.keys.a) moveX -= 1;
                if (state.keys.d) moveX += 1;
            }

            // Normalize diagonal movement
            const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
            if (length > 0) {
                moveX /= length;
                moveZ /= length;
            }

            // Apply rotation to movement (forward is negative Z in Three.js)
            const sin = Math.sin(state.rotation.y);
            const cos = Math.cos(state.rotation.y);
            
            // Forward/back aligned with camera direction
            state.velocity.x += (moveZ * sin + moveX * cos) * speed;
            state.velocity.z += (moveZ * cos - moveX * sin) * speed;

            // Apply friction
            state.velocity.x *= state.friction;
            state.velocity.z *= state.friction;

            // Update position
            state.position.x += state.velocity.x;
            state.position.z += state.velocity.z;

            // Update camera
            camera.position.set(state.position.x, state.position.y, state.position.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = state.rotation.y;
            camera.rotation.x = state.rotation.x;
        }

        let lastSync = 0;
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            
            updateMovement();
            
            // Animate cosmic radiation streams (slow rotation)
            radiationStreams.forEach(stream => {
                stream.rotation.y += stream.userData.rotationSpeed * stream.userData.direction;
            });
            
            // Animate heavenly fog particles (gentle drift)
            if (heavenlyFogParticles) {
                const positions = heavenlyFogParticles.geometry.attributes.position.array;
                const time = Date.now() * 0.0001;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += Math.sin(time + i) * 0.02;
                    positions[i + 2] += Math.cos(time + i) * 0.02;
                    
                    // Slowly descend and reset
                    positions[i + 1] -= 0.01;
                    if (positions[i + 1] < 40) {
                        positions[i + 1] = 110;
                    }
                }
                heavenlyFogParticles.geometry.attributes.position.needsUpdate = true;
            }
            
            // Sync position every 50ms
            if (Date.now() - lastSync > 50) {
                syncPosition();
                lastSync = Date.now();
            }
            
            renderer.render(scene, camera);
        }

        // ============== INIT ==============
        function init() {
            // Set your color indicator
            document.getElementById('yourColor').style.backgroundColor = state.playerColor;
            document.getElementById('yourColor').style.color = state.playerColor;

            initThree();
            initControls();
            initFirebase();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1500);
            
            gameLoop();
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>